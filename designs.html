<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Land Lens Designs</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f7;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #f7fafc, #edf2f7);
      color: #1a202c;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 20px 80px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 24px;
    }

    h1 {
      margin: 0;
      font-size: 2rem;
    }

    p {
      margin: 0;
      color: #4a5568;
    }

    section {
      background: #fff;
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
    }

    section h2 {
      margin-top: 0;
      font-size: 1.25rem;
      color: #1a202c;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    label {
      display: flex;
      flex-direction: column;
      font-weight: 600;
      color: #2d3748;
      font-size: 0.95rem;
    }

    input[type="text"],
    input[type="file"],
    textarea,
    select {
      margin-top: 6px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #cbd5f5;
      font-size: 0.95rem;
      font-family: inherit;
      background: #fdfefe;
    }

    textarea {
      min-height: 90px;
      resize: vertical;
    }

    button {
      border: none;
      border-radius: 8px;
      background: #2563eb;
      color: #fff;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 0.95rem;
    }

    button:hover {
      background: #1d4ed8;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #1a202c;
    }

    .btn-secondary:hover {
      background: #cbd5e0;
    }

    .status {
      margin-top: 12px;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .status.error {
      color: #d93025;
    }

    .canvas-panel {
      margin-top: 20px;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      background: #f8fafc;
    }

    .canvas-panel h3 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      color: #1f2937;
    }

    #shrinkwrapCanvas {
      width: 100%;
      max-width: 500px;
      height: 500px;
      border-radius: 12px;
      background: #0f172a;
      display: block;
      margin: 0 auto;
    }

    .canvas-instructions {
      margin: 8px 0 0;
      font-size: 0.9rem;
      color: #334155;
      text-align: center;
    }

    .list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .card {
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 14px;
      background: #fff;
    }

    .card header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 8px;
    }

    .card header h3 {
      margin: 0;
      font-size: 1rem;
      color: #1a202c;
    }

    .chip {
      background: #ebf4ff;
      color: #1e429f;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    pre {
      background: #0f172a;
      color: #f8fafc;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      overflow-x: auto;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Design Library</h1>
      <p>Upload DXF design files, review shrink-wrap/frontage data, and save ready-to-run designs.</p>
    </header>

    <section id="settingsSection">
      <h2>API target</h2>
      <p>Point this dashboard at the Parcel Crawl service (default: current origin). Override the base URL if the API lives elsewhere.</p>
      <form id="apiForm" class="form-grid">
        <label style="grid-column: 1 / -1">
          Base URL
          <input type="text" id="apiBaseInput" placeholder="https://landlens.up.railway.app">
        </label>
        <div class="actions" style="margin-top:8px">
          <button type="submit">Apply</button>
          <button type="button" class="btn-secondary" id="resetApiBtn">Use current origin</button>
        </div>
        <div id="apiStatus" class="status" style="grid-column: 1 / -1"></div>
      </form>
    </section>

    <section id="uploadSection">
      <h2>Upload design files</h2>
      <form id="uploadForm">
        <div class="form-grid">
          <label>
            File (DXF or ZIP)
            <input type="file" id="designFile" accept=".dxf,.zip" required>
          </label>
          <label>
            Optional filename override
            <input type="text" id="filenameOverride" placeholder="my_design.dxf">
          </label>
        </div>
        <div class="actions" style="margin-top:16px">
          <button type="submit">Upload</button>
          <button type="button" class="btn-secondary" id="refreshFilesBtn">Refresh file list</button>
        </div>
        <div id="uploadStatus" class="status"></div>
      </form>
    </section>

    <section id="filesSection">
      <h2>Uploaded files</h2>
      <ul id="filesList" class="list"></ul>
      <div id="filesStatus" class="status"></div>
    </section>

    <section id="shrinkwrapSection">
      <h2>Shrink-wrap & frontage</h2>
      <p>Select an uploaded file and mark the rectangle + frontage using the visual picker, or paste coordinates manually.</p>
      <form id="shrinkwrapForm">
        <div class="form-grid">
          <label>
            Select file
            <select id="shrinkwrapFileSelect" required>
              <option value="">-- Choose a file --</option>
            </select>
          </label>
          <label>
            Rectangle points (3)
            <textarea id="rectanglePointsInput" placeholder='[[x1,y1],[x2,y2],[x3,y3]]'></textarea>
          </label>
          <label>
            Frontage points (2)
            <textarea id="frontPointsInput" placeholder='[[x1,y1],[x2,y2]]'></textarea>
          </label>
        </div>
        <div class="actions" style="margin-top:16px">
          <button type="submit">Generate shrink-wrap</button>
        </div>
        <div id="shrinkwrapStatus" class="status"></div>
      </form>

      <div class="canvas-panel" id="canvasPanel">
        <h3>Visual picker</h3>
        <canvas id="shrinkwrapCanvas" width="520" height="520"></canvas>
        <div class="canvas-instructions" id="canvasInstructions">Select a file to load its footprint preview.</div>
        <div class="actions" style="margin-top:8px; justify-content:center;">
          <button type="button" class="btn-secondary" id="resetCanvasBtn">Reset selections</button>
        </div>
        <div id="canvasStatus" class="status" style="text-align:center;"></div>
      </div>

      <div id="shrinkwrapResult" class="card hidden" style="margin-top:18px;">
        <header>
          <h3>Latest shrink-wrap result</h3>
          <span class="chip" id="shrinkwrapResultFile"></span>
        </header>
        <pre id="shrinkwrapResultData"></pre>
        <div class="actions">
          <label style="flex:1;">
            Design name
            <input type="text" id="designNameInput" placeholder="Modern Ranch A">
          </label>
          <button id="saveDesignBtn" type="button">Save design</button>
        </div>
        <div id="saveDesignStatus" class="status"></div>
      </div>
    </section>

    <section id="designsSection">
      <h2>Saved designs & shrink-wraps</h2>
      <ul id="designsList" class="list"></ul>
      <div id="designsStatus" class="status"></div>
    </section>
  </div>

  <script>
    const API_STORAGE_KEY = "designs-api-base";
    const DEFAULT_API_BASE = "https://landlens.up.railway.app";
    let apiBase = DEFAULT_API_BASE;

    const state = {
      files: [],
      designs: [],
      previews: {},
      geometries: {},
      lastShrinkwrap: null,
      canvas: {
        footprint: null,
        shapes: [],
        transform: null,
        rectangle: [],
        frontage: [],
        file: null
      }
    };

    const elements = {
      apiStatus: document.getElementById("apiStatus"),
      apiBaseInput: document.getElementById("apiBaseInput"),
      filesList: document.getElementById("filesList"),
      filesStatus: document.getElementById("filesStatus"),
      uploadStatus: document.getElementById("uploadStatus"),
      shrinkwrapStatus: document.getElementById("shrinkwrapStatus"),
      designsStatus: document.getElementById("designsStatus"),
      shrinkwrapResult: document.getElementById("shrinkwrapResult"),
      shrinkwrapResultData: document.getElementById("shrinkwrapResultData"),
      shrinkwrapResultFile: document.getElementById("shrinkwrapResultFile"),
      saveDesignStatus: document.getElementById("saveDesignStatus"),
      shrinkwrapFileSelect: document.getElementById("shrinkwrapFileSelect"),
      designsList: document.getElementById("designsList"),
      shrinkwrapCanvas: document.getElementById("shrinkwrapCanvas"),
      canvasStatus: document.getElementById("canvasStatus"),
      canvasInstructions: document.getElementById("canvasInstructions"),
      resetCanvasBtn: document.getElementById("resetCanvasBtn")
    };

    function buildUrl(path) {
      const trimmedBase = apiBase?.trim();
      if (!trimmedBase) return path;
      const cleanBase = trimmedBase.endsWith("/") ? trimmedBase.slice(0, -1) : trimmedBase;
      const cleanPath = path.startsWith("/") ? path : `/${path}`;
      return `${cleanBase}${cleanPath}`;
    }

    async function fetchJSON(path, options = {}) {
      const response = await fetch(buildUrl(path), options);
      if (!response.ok) {
        const body = await response.text();
        throw new Error(`Request failed (${response.status}): ${body || response.statusText}`);
      }
      return response.json();
    }

    function normalizeFiles(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.files)) return payload.files;
      return [];
    }

    function normalizeDesigns(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.designs)) return payload.designs;
      return [];
    }

    function getFileName(file) {
      return file?.name || file?.filename || file?.key || file?.path || "unknown";
    }

    function getFileUrl(file) {
      return file?.file_url || file?.download_url || file?.url || "";
    }

    function setStatus(el, message, type = "info") {
      if (!el) return;
      if (!message) {
        el.textContent = "";
        el.classList.remove("error");
        return;
      }
      el.textContent = message;
      el.classList.toggle("error", type === "error");
    }

    async function loadFiles() {
      setStatus(elements.filesStatus, "Loading files...");
      try {
        const payload = await fetchJSON("/files");
        state.files = normalizeFiles(payload);
        renderFiles();
        populateFileSelect();
        setStatus(elements.filesStatus, `Loaded ${state.files.length} file(s).`);
      } catch (err) {
        console.error(err);
        setStatus(elements.filesStatus, err.message, "error");
      }
    }

    async function loadDesigns() {
      setStatus(elements.designsStatus, "Loading designs...");
      try {
        const payload = await fetchJSON("/designs");
        state.designs = normalizeDesigns(payload);
        renderDesigns();
        setStatus(elements.designsStatus, `Loaded ${state.designs.length} design(s).`);
      } catch (err) {
        console.error(err);
        setStatus(elements.designsStatus, err.message, "error");
      }
    }

    function renderFiles() {
      elements.filesList.innerHTML = "";
      if (!state.files.length) {
        elements.filesList.innerHTML = "<li>No files uploaded yet.</li>";
        return;
      }
      state.files.forEach((file) => {
        const li = document.createElement("li");
        li.className = "card";
        const name = getFileName(file);
        const uploaded = file?.uploaded_at ? new Date(file.uploaded_at).toLocaleString() : "unknown";
        const info = document.createElement("div");
        info.innerHTML = `
          <header>
            <h3>${name}</h3>
            <span class="chip">${uploaded}</span>
          </header>
          <div>Size: ${file?.size ? `${(file.size / 1024).toFixed(1)} KB` : "N/A"}</div>
          <div>Source: ${getFileUrl(file) || "N/A"}</div>
        `;
        li.appendChild(info);

        const actions = document.createElement("div");
        actions.className = "actions";
        if (getFileUrl(file)) {
          const link = document.createElement("a");
          link.href = getFileUrl(file);
          link.target = "_blank";
          link.rel = "noopener";
          link.className = "btn-secondary";
          link.textContent = "Download";
          actions.appendChild(link);
        }

        const previewBtn = document.createElement("button");
        previewBtn.type = "button";
        previewBtn.className = "btn-secondary";
        previewBtn.textContent = "Auto preview shrink-wrap";
        previewBtn.addEventListener("click", () => previewShrinkwrap(name));
        actions.appendChild(previewBtn);
        li.appendChild(actions);

        const previewOutput = document.createElement("pre");
        previewOutput.className = "hidden";
        previewOutput.id = `preview-${CSS.escape(name)}`;
        li.appendChild(previewOutput);

        elements.filesList.appendChild(li);
      });
    }

    function populateFileSelect() {
      const select = elements.shrinkwrapFileSelect;
      const current = select.value;
      select.innerHTML = '<option value="">-- Choose a file --</option>';
      state.files.forEach((file) => {
        const name = getFileName(file);
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      });
      if (current) {
        select.value = current;
      }
      if (select.value && select.value !== state.canvas.file) {
        loadCanvasForFile(select.value);
      }
    }

    async function fetchPreviewData(filename) {
      if (!filename) return null;
      if (state.previews[filename]) return state.previews[filename];
      const data = await fetchJSON(`/files/${encodeURIComponent(filename)}/preview`);
      state.previews[filename] = data;
      return data;
    }

    async function fetchGeometryData(filename) {
      if (!filename) return null;
      if (state.geometries[filename]) return state.geometries[filename];
      const data = await fetchJSON(`/files/${encodeURIComponent(filename)}/geometry`);
      state.geometries[filename] = data;
      return data;
    }

    async function previewShrinkwrap(filename) {
      if (!filename) return;
      setStatus(elements.filesStatus, `Previewing shrink-wrap for ${filename}...`);
      try {
        const data = await fetchPreviewData(filename);
        showPreview(filename, data);
        setStatus(elements.filesStatus, `Preview ready for ${filename}.`);
        if (elements.shrinkwrapFileSelect.value === filename) {
          applyPreviewToCanvas(filename, data);
        }
      } catch (err) {
        console.error(err);
        setStatus(elements.filesStatus, err.message, "error");
      }
    }

    function showPreview(filename, data) {
      const pre = document.getElementById(`preview-${CSS.escape(filename)}`);
      if (!pre) return;
      pre.textContent = JSON.stringify(data, null, 2);
      pre.classList.remove("hidden");
    }

    function parsePointsInput(value, expected) {
      if (!value) return [];
      const trimmed = value.trim();
      if (!trimmed) return [];
      try {
        const parsed = JSON.parse(trimmed);
        if (Array.isArray(parsed)) return parsed;
      } catch (err) {
        const parts = trimmed.split(/\n|;/).map((row) => row.trim()).filter(Boolean);
        const coords = parts.map((row) => row.split(/[, ]+/).map((n) => Number(n.trim())).slice(0, 2));
        if (coords.length) return coords;
      }
      throw new Error(`Could not parse points input. Expected ${expected} coordinate pairs.`);
    }

    async function handleUpload(event) {
      event.preventDefault();
      const fileInput = document.getElementById("designFile");
      const overrideInput = document.getElementById("filenameOverride");
      if (!fileInput.files.length) {
        setStatus(elements.uploadStatus, "Pick a file first.", "error");
        return;
      }
      const formData = new FormData();
      formData.append("file", fileInput.files[0]);
      const override = overrideInput.value.trim();
      setStatus(elements.uploadStatus, "Uploading...");
      try {
        const query = override ? `?filename=${encodeURIComponent(override)}` : "";
        const payload = await fetchJSON(`/files${query}`, { method: "POST", body: formData });
        setStatus(elements.uploadStatus, `Upload complete: ${payload?.name || payload?.filename || "success"}`);
        fileInput.value = "";
        overrideInput.value = "";
        await loadFiles();
      } catch (err) {
        console.error(err);
        setStatus(elements.uploadStatus, err.message, "error");
      }
    }

    async function handleShrinkwrap(event) {
      event.preventDefault();
      const filename = elements.shrinkwrapFileSelect.value;
      if (!filename) {
        setStatus(elements.shrinkwrapStatus, "Select a file first.", "error");
        return;
      }
      try {
        const rectangle = parsePointsInput(document.getElementById("rectanglePointsInput").value, 3);
        const frontPoints = parsePointsInput(document.getElementById("frontPointsInput").value, 2);
        if (rectangle.length !== 3) throw new Error("Rectangle points must contain exactly 3 vertices.");
        if (frontPoints.length !== 2) throw new Error("Frontage points must contain exactly 2 vertices.");
        setStatus(elements.shrinkwrapStatus, "Submitting shrink-wrap request...");
        const payload = await fetchJSON(`/files/${encodeURIComponent(filename)}/shrinkwrap`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ rectangle_points: rectangle, front_points: frontPoints })
        });
        state.lastShrinkwrap = { filename, data: payload };
        renderShrinkwrapResult();
        setStatus(elements.shrinkwrapStatus, "Shrink-wrap ready. Review below.");
      } catch (err) {
        console.error(err);
        setStatus(elements.shrinkwrapStatus, err.message, "error");
      }
    }

    function renderShrinkwrapResult() {
      if (!state.lastShrinkwrap) {
        elements.shrinkwrapResult.classList.add("hidden");
        return;
      }
      elements.shrinkwrapResult.classList.remove("hidden");
      elements.shrinkwrapResultFile.textContent = state.lastShrinkwrap.filename;
      elements.shrinkwrapResultData.textContent = JSON.stringify(state.lastShrinkwrap.data, null, 2);
      setStatus(elements.saveDesignStatus, "");
    }

    async function handleSaveDesign() {
      if (!state.lastShrinkwrap) {
        setStatus(elements.saveDesignStatus, "Run shrink-wrap first.", "error");
        return;
      }
      const nameInput = document.getElementById("designNameInput");
      const designName = nameInput.value.trim();
      if (!designName) {
        setStatus(elements.saveDesignStatus, "Provide a design name.", "error");
        return;
      }
      const fileMeta = state.files.find((f) => getFileName(f) === state.lastShrinkwrap.filename);
      if (!fileMeta) {
        setStatus(elements.saveDesignStatus, "Unable to locate file metadata for selected shrink-wrap.", "error");
        return;
      }
      const payload = {
        name: designName,
        dxf_url: getFileUrl(fileMeta),
        footprint_points: state.lastShrinkwrap.data?.footprint_points,
        front_direction: state.lastShrinkwrap.data?.front_direction
      };
      if (!payload.dxf_url) {
        setStatus(elements.saveDesignStatus, "File URL missing; cannot save design.", "error");
        return;
      }
      setStatus(elements.saveDesignStatus, "Saving design...");
      try {
        await fetchJSON("/designs", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        setStatus(elements.saveDesignStatus, "Design saved.");
        nameInput.value = "";
        await loadDesigns();
      } catch (err) {
        console.error(err);
        setStatus(elements.saveDesignStatus, err.message, "error");
      }
    }

    function renderDesigns() {
      elements.designsList.innerHTML = "";
      if (!state.designs.length) {
        elements.designsList.innerHTML = "<li>No saved designs yet.</li>";
        return;
      }
      state.designs.forEach((design) => {
        const li = document.createElement("li");
        li.className = "card";
        const header = document.createElement("header");
        const title = document.createElement("h3");
        title.textContent = design?.name || design?.slug || "untitled";
        header.appendChild(title);
        if (design?.updated_at) {
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = new Date(design.updated_at).toLocaleString();
          header.appendChild(chip);
        }
        li.appendChild(header);
        const body = document.createElement("div");
        body.innerHTML = `
          <div><strong>DXF:</strong> ${design?.dxf_url || "N/A"}</div>
          <div><strong>Front direction:</strong> ${JSON.stringify(design?.front_direction || [])}</div>
          <div><strong>Footprint points:</strong></div>
        `;
        li.appendChild(body);
        const pre = document.createElement("pre");
        pre.textContent = JSON.stringify(design?.footprint_points || [], null, 2);
        li.appendChild(pre);
        elements.designsList.appendChild(li);
      });
    }

    function initApiBase() {
      const params = new URLSearchParams(window.location.search);
      const queryBase = params.get("api");
      const storedBase = localStorage.getItem(API_STORAGE_KEY);
      const initial = queryBase ?? storedBase ?? DEFAULT_API_BASE;
      applyApiBase(initial, false);
    }

    function applyApiBase(value, persist = true) {
      apiBase = (value || "").trim();
      elements.apiBaseInput.value = apiBase;
      if (persist) {
        if (apiBase) {
          localStorage.setItem(API_STORAGE_KEY, apiBase);
        } else {
          localStorage.removeItem(API_STORAGE_KEY);
        }
      }
      setStatus(elements.apiStatus, apiBase ? `Using API base ${apiBase}` : "Using current origin");
    }

    function handleApiForm(event) {
      event.preventDefault();
      applyApiBase(elements.apiBaseInput.value, true);
      loadFiles();
      loadDesigns();
    }

    function resetApiBase() {
      applyApiBase("", true);
      loadFiles();
      loadDesigns();
    }

    function setCanvasStatus(message, type = "info") {
      setStatus(elements.canvasStatus, message, type);
    }

    function isValidPoint(point) {
      if (!point) return false;
      if (Array.isArray(point) && point.length >= 2) {
        return Number.isFinite(Number(point[0])) && Number.isFinite(Number(point[1]));
      }
      if (typeof point === "object" && ("x" in point || "y" in point)) {
        return Number.isFinite(Number(point.x ?? point.X)) && Number.isFinite(Number(point.y ?? point.Y));
      }
      return false;
    }

    function toPointArray(point) {
      if (!isValidPoint(point)) return null;
      if (Array.isArray(point)) {
        return [Number(point[0]), Number(point[1])];
      }
      return [Number(point.x ?? point.X ?? point.lon ?? point.longitude ?? 0), Number(point.y ?? point.Y ?? point.lat ?? point.latitude ?? 0)];
    }

    function normalizeGeometryShapes(payload) {
      if (!payload) return [];
      const candidateSets = [
        payload.polylines,
        payload.paths,
        payload.lines,
        payload.geometry,
        payload
      ];
      const firstArray = candidateSets.find((item) => Array.isArray(item));
      if (!Array.isArray(firstArray)) return [];
      return firstArray
        .map((path) => {
          if (Array.isArray(path?.points)) return path.points;
          if (Array.isArray(path)) return path;
          if (typeof path === "object" && Array.isArray(path.coordinates)) return path.coordinates;
          return null;
        })
        .filter(Boolean)
        .map((path) => path.map(toPointArray).filter(Boolean))
        .filter((path) => path.length >= 2);
    }

    function flattenPoints(shapes) {
      if (!Array.isArray(shapes)) return [];
      const result = [];
      shapes.forEach((shape) => {
        if (!Array.isArray(shape)) return;
        shape.forEach((point) => {
          const normalized = toPointArray(point);
          if (normalized) result.push(normalized);
        });
      });
      return result;
    }

    function projectPoint(point) {
      if (!state.canvas.transform) return null;
      const { padding, scale, minX, minY, height } = state.canvas.transform;
      const x = padding + (point[0] - minX) * scale;
      const y = height - (padding + (point[1] - minY) * scale);
      return [x, y];
    }

    function unprojectPoint(x, y) {
      if (!state.canvas.transform) return null;
      const { padding, scale, minX, minY, height } = state.canvas.transform;
      const designX = ((x - padding) / scale) + minX;
      const designY = (((height - y) - padding) / scale) + minY;
      return [designX, designY];
    }

    function renderCanvas() {
      const canvas = elements.shrinkwrapCanvas;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#0f172a";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const footprint = state.canvas.footprint;
      if (Array.isArray(footprint) && footprint.length) {
        ctx.strokeStyle = "#60a5fa";
        ctx.fillStyle = "rgba(96,165,250,0.15)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        footprint.forEach((point, index) => {
          const [x, y] = projectPoint(point) || [];
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else if (Array.isArray(state.canvas.shapes) && state.canvas.shapes.length) {
        ctx.strokeStyle = "#94a3b8";
        ctx.lineWidth = 1.5;
        state.canvas.shapes.forEach((shape) => {
          ctx.beginPath();
          shape.forEach((point, index) => {
            const [x, y] = projectPoint(point) || [];
            if (index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.stroke();
        });
      } else {
        ctx.fillStyle = "#94a3b8";
        ctx.font = "16px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Preview data not available", canvas.width / 2, canvas.height / 2);
      }

      const drawPoints = (points, color) => {
        ctx.fillStyle = color;
        points.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fill();
        });
      };

      const rectPoints = state.canvas.rectangle.map(projectPoint).filter(Boolean);
      if (rectPoints.length) {
        ctx.strokeStyle = "#fbbf24";
        ctx.lineWidth = 2;
        ctx.beginPath();
        rectPoints.forEach(([x, y], idx) => {
          if (idx === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        if (rectPoints.length === 3) ctx.closePath();
        ctx.stroke();
        drawPoints(rectPoints, "#fbbf24");
      }

      const frontPoints = state.canvas.frontage.map(projectPoint).filter(Boolean);
      if (frontPoints.length === 2) {
        ctx.strokeStyle = "#34d399";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(frontPoints[0][0], frontPoints[0][1]);
        ctx.lineTo(frontPoints[1][0], frontPoints[1][1]);
        ctx.stroke();
        drawPoints(frontPoints, "#34d399");
      } else if (frontPoints.length === 1) {
        drawPoints(frontPoints, "#34d399");
      }
    }

    function computeCanvasTransform(points) {
      if (!Array.isArray(points) || !points.length) return null;
      const valid = points
        .map((point) => (Array.isArray(point) ? point : toPointArray(point)))
        .filter((point) => Array.isArray(point) && point.length >= 2 && Number.isFinite(point[0]) && Number.isFinite(point[1]));
      if (!valid.length) return null;
      const xs = valid.map((p) => p[0]);
      const ys = valid.map((p) => p[1]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const width = maxX - minX || 1;
      const height = maxY - minY || 1;
      const padding = 30;
      const canvas = elements.shrinkwrapCanvas;
      if (!canvas) return null;
      const usableWidth = canvas.width - padding * 2;
      const usableHeight = canvas.height - padding * 2;
      const scale = Math.min(usableWidth / width, usableHeight / height);
      return { padding, scale, minX, minY, width: canvas.width, height: canvas.height };
    }

    async function loadCanvasForFile(filename) {
      state.canvas.rectangle = [];
      state.canvas.frontage = [];
       state.canvas.shapes = [];
      state.canvas.file = filename || null;
      updatePointInputsFromCanvas();
      if (!filename) {
        state.canvas.footprint = null;
        state.canvas.transform = null;
        setCanvasStatus("Select a file to begin.");
        elements.canvasInstructions.textContent = "Select a file to load its footprint preview.";
        renderCanvas();
        return;
      }
      setCanvasStatus(`Loading preview for ${filename}...`);
      try {
        const data = await fetchPreviewData(filename);
        applyPreviewToCanvas(filename, data);
      } catch (err) {
        console.error(err);
        setCanvasStatus(`Preview unavailable: ${err.message}`, "error");
        try {
          const geometry = await fetchGeometryData(filename);
          const applied = applyGeometryToCanvas(filename, geometry);
          if (applied) return;
        } catch (geoErr) {
          console.error(geoErr);
          setCanvasStatus(`Geometry fallback failed: ${geoErr.message}`, "error");
        }
        state.canvas.footprint = null;
        state.canvas.shapes = [];
        state.canvas.transform = null;
        renderCanvas();
      }
    }

    function applyPreviewToCanvas(filename, data) {
      if (!data || !Array.isArray(data.footprint_points)) {
        setCanvasStatus("Preview did not include footprint points.", "error");
        state.canvas.footprint = null;
        state.canvas.transform = null;
        renderCanvas();
        return;
      }
      state.canvas.file = filename;
      state.canvas.footprint = data.footprint_points;
      state.canvas.shapes = [state.canvas.footprint];
      state.canvas.transform = computeCanvasTransform(data.footprint_points);
      if (Array.isArray(data.rectangle_points) && data.rectangle_points.length >= 3) {
        state.canvas.rectangle = data.rectangle_points.slice(0, 3);
      }
      if (Array.isArray(data.front_points) && data.front_points.length >= 2) {
        state.canvas.frontage = data.front_points.slice(0, 2);
      }
      elements.canvasInstructions.textContent = "Click 3 points for the rectangle, then 2 points for the frontage line.";
      if (state.canvas.rectangle.length < 3) {
        setCanvasStatus("Select 3 rectangle corners.");
      } else if (state.canvas.frontage.length < 2) {
        setCanvasStatus("Select 2 frontage points.");
      } else {
        setCanvasStatus("Selections ready. You can adjust by clicking Reset.");
      }
      updatePointInputsFromCanvas();
      renderCanvas();
    }

    function applyGeometryToCanvas(filename, geometryData) {
      const shapes = normalizeGeometryShapes(geometryData);
      if (!shapes.length) {
        setCanvasStatus("Geometry endpoint returned no usable paths.", "error");
        return false;
      }
      state.canvas.file = filename;
      state.canvas.footprint = null;
      state.canvas.shapes = shapes;
      const pointsForTransform = flattenPoints(shapes);
      state.canvas.transform = computeCanvasTransform(pointsForTransform);
      elements.canvasInstructions.textContent = "Preview unavailable; using geometry fallback. Click 3 rectangle points, then 2 frontage points.";
      setCanvasStatus("Preview unavailable; using geometry fallback.");
      updatePointInputsFromCanvas();
      renderCanvas();
      return true;
    }

    function updatePointInputsFromCanvas() {
      const rectInput = document.getElementById("rectanglePointsInput");
      const frontInput = document.getElementById("frontPointsInput");
      if (rectInput && state.canvas.rectangle.length) {
        rectInput.value = JSON.stringify(state.canvas.rectangle, null, 2);
      }
      if (frontInput && state.canvas.frontage.length) {
        frontInput.value = JSON.stringify(state.canvas.frontage, null, 2);
      }
    }

    function handleCanvasClick(event) {
      if (!state.canvas.transform || !state.canvas.file) return;
      const canvas = elements.shrinkwrapCanvas;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const designPoint = unprojectPoint(x, y);
      if (!designPoint) return;
      const formatted = designPoint.map((value) => Number(value.toFixed(4)));
      if (state.canvas.rectangle.length < 3) {
        state.canvas.rectangle.push(formatted);
        setCanvasStatus(
          state.canvas.rectangle.length < 3
            ? `Rectangle point ${state.canvas.rectangle.length}/3`
            : "Rectangle ready. Now select 2 frontage points."
        );
      } else if (state.canvas.frontage.length < 2) {
        state.canvas.frontage.push(formatted);
        setCanvasStatus(
          state.canvas.frontage.length < 2
            ? "Select one more frontage point."
            : "Selections ready. You can tweak or submit."
        );
      } else {
        // All points already selected; reset prompt
        setCanvasStatus("Selections complete. Reset to adjust.");
        return;
      }
      updatePointInputsFromCanvas();
      renderCanvas();
    }

    function resetCanvasSelections() {
      state.canvas.rectangle = [];
      state.canvas.frontage = [];
      setCanvasStatus("Selections cleared. Click 3 rectangle points.");
      const rectInput = document.getElementById("rectanglePointsInput");
      const frontInput = document.getElementById("frontPointsInput");
      if (rectInput) rectInput.value = "";
      if (frontInput) frontInput.value = "";
      updatePointInputsFromCanvas();
      renderCanvas();
    }

    document.getElementById("apiForm").addEventListener("submit", handleApiForm);
    document.getElementById("resetApiBtn").addEventListener("click", resetApiBase);
    document.getElementById("uploadForm").addEventListener("submit", handleUpload);
    document.getElementById("refreshFilesBtn").addEventListener("click", loadFiles);
    document.getElementById("shrinkwrapForm").addEventListener("submit", handleShrinkwrap);
    document.getElementById("saveDesignBtn").addEventListener("click", handleSaveDesign);
    if (elements.shrinkwrapFileSelect) {
      elements.shrinkwrapFileSelect.addEventListener("change", (event) => {
        loadCanvasForFile(event.target.value);
      });
    }
    if (elements.shrinkwrapCanvas) {
      elements.shrinkwrapCanvas.addEventListener("click", handleCanvasClick);
    }
    if (elements.resetCanvasBtn) {
      elements.resetCanvasBtn.addEventListener("click", resetCanvasSelections);
    }

    initApiBase();
    loadFiles();
    loadDesigns();
  </script>
</body>
</html>
