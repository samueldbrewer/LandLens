<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MapTiler Map</title>
    <link
      href="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
      }

      #map {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      .status-banner {
        position: absolute;
        background: rgba(255, 255, 255, 0.94);
        padding: 8px 12px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        font-weight: 600;
        z-index: 1;
      }

      .status-banner {
        top: 12px;
        right: 12px;
        max-width: 280px;
        font-size: 0.85rem;
        font-weight: 500;
      }

      .status-banner.error {
        border: 1px solid #d93025;
        color: #d93025;
      }

      .status-banner.hidden {
        display: none;
      }

      body.mobile-mode .desktop-only {
        display: none !important;
      }

      body:not(.mobile-mode) .mobile-only {
        display: none !important;
      }

      .control-panel {
        position: absolute;
        top: 12px;
        left: 12px;
        width: 420px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 10px;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.15);
        padding: 14px 16px 18px;
        z-index: 2;
        display: flex;
        flex-direction: column;
        gap: 12px;
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      .panel-section h1 {
        font-size: 1.2rem;
        margin: 0;
        color: #0f172a;
      }

      .panel-section p {
        margin: 4px 0 0;
        color: #475569;
        font-size: 0.9rem;
        line-height: 1.4;
      }

      .panel-section label {
        font-size: 0.9rem;
        font-weight: 600;
        color: #0f172a;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .panel-section select,
      .panel-section button {
        font-family: inherit;
        font-size: 0.95rem;
        border-radius: 8px;
        border: 1px solid #cbd5f5;
        padding: 8px 10px;
      }

      .panel-section select {
        background: #fff;
      }

      .panel-section button {
        border: none;
        background: #2563eb;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .panel-section button:hover {
        background: #1e4fd6;
      }

      .panel-section button:disabled,
      .panel-section select:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #0f172a;
      }

      .panel-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .panel-status {
        font-size: 0.85rem;
        color: #475569;
      }

      .panel-status.error {
        color: #d93025;
      }

      .log-section {
        border-top: 1px solid rgba(148, 163, 184, 0.35);
        padding-top: 12px;
      }

      .log-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .log-feed {
        margin-top: 10px;
        max-height: 320px;
        overflow-y: auto;
        background: #0f172a;
        border-radius: 8px;
        padding: 10px;
        color: #e2e8f0;
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .log-entry {
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        padding: 6px 0;
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry strong {
        color: #f8fafc;
        display: block;
      }

      .log-entry pre {
        margin: 4px 0 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "SFMono-Regular", Consolas, monospace;
        background: rgba(15, 23, 42, 0.7);
        padding: 6px;
        border-radius: 4px;
        color: #cbd5f5;
      }

      .job-status {
        font-weight: 600;
        color: #0f172a;
      }

      .job-meta {
        font-size: 0.85rem;
        color: #475569;
        margin-top: 4px;
      }

      .log-tail-label {
        margin-top: 10px;
        font-size: 0.85rem;
        font-weight: 600;
        color: #0f172a;
      }

      .log-tail {
        background: #0f172a;
        color: #e2e8f0;
        border-radius: 6px;
        padding: 8px;
        font-size: 0.78rem;
        line-height: 1.35;
        max-height: 150px;
        overflow-y: auto;
        margin-top: 4px;
        white-space: pre-wrap;
      }
      .event-log {
        background: #020617;
        color: #c7d2fe;
        border-radius: 6px;
        padding: 8px;
        font-size: 0.75rem;
        line-height: 1.35;
        max-height: 180px;
        overflow-y: auto;
        margin-top: 4px;
        white-space: pre-wrap;
        border: 1px solid rgba(99, 102, 241, 0.4);
      }

      @media (max-width: 640px) {
        .control-panel {
          width: calc(100% - 24px);
          left: 12px;
          right: 12px;
          top: auto;
          bottom: 12px;
        }

        .panel-actions {
          flex-direction: column;
        }

        .panel-section button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="control-panel">
      <div class="panel-section">
        <h1>Land Lens Runner</h1>
        <p>
          Select a saved shrink-wrap, then click a spot on the map to start a
          crawl.
        </p>
      </div>
      <div class="panel-section mobile-only">
        <p style="margin: 0; color: #475569; font-size: 0.9rem">
          Tap anywhere on the map after picking a design. We'll stream results
          below.
        </p>
      </div>
      <div class="panel-section">
        <label>
          Shrink-wrap design
          <select id="designSelect">
            <option value="">Loading designs…</option>
          </select>
        </label>
        <div class="panel-actions">
          <button id="refreshDesignsBtn" type="button">Refresh designs</button>
        </div>
        <div id="designStatus" class="panel-status"></div>
      </div>
      <div class="panel-section" id="designPreviewSection">
        <strong style="color: #0f172a">Design preview</strong>
        <pre
          id="designPreview"
          style="
            background: #0f172a;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
          "
        >
Select a design to preview shrink-wrap metadata.</pre
        >
      </div>
      <div class="panel-section">
        <div id="jobStatusText" class="job-status">
          Select a design, then click the map.
        </div>
        <div id="jobMetaText" class="job-meta"></div>
        <div class="panel-actions">
          <button
            id="cancelJobBtn"
            class="btn-secondary"
            type="button"
            disabled
          >
            Cancel active job
          </button>
        </div>
      </div>
      <div class="panel-section desktop-only" id="layerSummary">
        <div class="panel-status" id="parcelSummary">Parcels: 0</div>
        <div class="panel-status" id="placementSummary">Placements: 0</div>
        <div class="panel-status" id="shadowSummary">Shadows: 0</div>
      </div>
      <div class="panel-section desktop-only">
        <strong style="color: #0f172a">Backend log (latest)</strong>
        <pre id="logTail" class="log-tail">No log output yet.</pre>
      </div>
      <div class="panel-section desktop-only">
        <strong style="color: #0f172a">Live event stream</strong>
        <p class="panel-status" style="margin: 4px 0 0">
          Raw parcel / placement events as they arrive from the crawler.
        </p>
        <pre id="eventStreamLog" class="event-log">No events yet.</pre>
      </div>
    </div>
    <div id="status" class="status-banner hidden"></div>
    <div id="map"></div>

    <script>
      const key = "CBo7orMIbQ1XA33zeKV8";
      const styleUrl = `https://api.maptiler.com/maps/streets-v2/style.json?key=${key}`;
      const API_BASE = "https://landlens.up.railway.app";
      const JOB_SOURCE_ID = "job-parcels";
      const JOB_FILL_LAYER_ID = "job-parcels-fill";
      const JOB_LINE_LAYER_ID = "job-parcels-outline";
      const PARCEL_BOUNDARY_SOURCE_ID = "parcel-boundaries";
      const PARCEL_BOUNDARY_LAYER_ID = "parcel-boundaries-fill";
      const PLACEMENT_SOURCE_ID = "parcel-placements";
      const PLACEMENT_LAYER_ID = "parcel-placements-fill";
      const SHADOW_SOURCE_ID = "parcel-shadows";
      const SHADOW_LAYER_ID = "parcel-shadows-fill";
      const PLACEMENT_LABEL_SOURCE_ID = "placement-labels";
      const PLACEMENT_LABEL_LAYER_ID = "placement-labels-symbol";
      const JOB_STATUS_POLL_MS = 5000;
      const JOB_GEO_POLL_MS = 4000;
      const JOB_ARTIFACT_POLL_MS = 8000;
      const EVENT_POLL_INTERVAL_MS = 1500;
      const EVENT_POLL_MAX_BYTES = 200000;
      const EVENT_LOG_LIMIT = 200;
      const EMPTY_GEOJSON = { type: "FeatureCollection", features: [] };

      maplibregl.workerUrl = "./maplibre-gl-csp-worker.js";
      maplibregl.workerCount = 2;
      let map;
      let longPressTimer;
      let longPressCoords = null;
      let suppressNextClick = false;

      const statusEl = document.getElementById("status");
      const ui = {
        designSelect: document.getElementById("designSelect"),
        designStatus: document.getElementById("designStatus"),
        refreshDesignsBtn: document.getElementById("refreshDesignsBtn"),
        jobStatusText: document.getElementById("jobStatusText"),
        jobMetaText: document.getElementById("jobMetaText"),
        cancelJobBtn: document.getElementById("cancelJobBtn"),
        parcelSummary: document.getElementById("parcelSummary"),
        placementSummary: document.getElementById("placementSummary"),
        shadowSummary: document.getElementById("shadowSummary"),
        logTail: document.getElementById("logTail"),
        designPreview: document.getElementById("designPreview"),
        eventStreamLog: document.getElementById("eventStreamLog"),
      };

      const appState = {
        designs: [],
        selectedDesign: null,
        job: null,
        pollTimers: { status: null, geo: null, artifacts: null },
        abortControllers: new Set(),
        jobMarker: null,
        overlayCache: {
          data: {},
          index: 0,
          jobId: null,
        },
        overlayData: {
          parcels: EMPTY_GEOJSON,
          placements: EMPTY_GEOJSON,
          shadows: EMPTY_GEOJSON,
          labels: EMPTY_GEOJSON,
        },
        designPreviews: {},
        eventStreamState: {
          jobId: null,
          timer: null,
          cursor: 0,
          pending: false,
        },
        overlayRefreshPending: false,
        overlayStore: {
          parcels: new Map(),
          placements: new Map(),
          shadows: new Map(),
          labels: new Map(),
          best: new Map(),
          nextPlacementIndex: new Map(),
        },
        eventFeed: [],
      };

      function getDesignFilename(design) {
        const url = design?.dxf_url;
        if (!url) return null;
        try {
          if (url.startsWith("file://")) {
            const path = url.replace("file://", "");
            const parts = path.split("/").filter(Boolean);
            return parts.pop();
          }
          const parsed = new URL(url);
          const segments = parsed.pathname.split("/").filter(Boolean);
          return segments.pop();
        } catch (err) {
          return null;
        }
      }

      function normalizeArtifactUrl(url) {
        if (!url) return null;
        try {
          if (url.startsWith("/")) return url;
          if (url.startsWith("http://landlens.up.railway.app")) {
            return url.replace(
              "http://landlens.up.railway.app",
              "https://landlens.up.railway.app",
            );
          }
          if (url.startsWith("http://")) {
            return url.replace("http://", "https://");
          }
          return url;
        } catch (err) {
          return url;
        }
      }

      function resetDesignPreview() {
        if (!ui.designPreview) return;
        ui.designPreview.textContent =
          "Select a design to preview shrink-wrap metadata.";
      }

      function renderDesignPreview(design, previewData) {
        if (!ui.designPreview) return;
        if (!design) {
          resetDesignPreview();
          return;
        }
        const lines = [];
        lines.push(`Name: ${design.name || design.slug || "Untitled"}`);
        const footprintCount = design?.footprint_points?.length;
        lines.push(
          `Footprint points: ${
            typeof footprintCount === "number" ? footprintCount : "n/a"
          }`,
        );
        lines.push(
          `Front direction: ${
            design?.front_direction
              ? JSON.stringify(design.front_direction)
              : "auto"
          }`,
        );
        if (previewData) {
          lines.push(
            `Preview rectangle: ${
              previewData.rectangle_points
                ? JSON.stringify(previewData.rectangle_points)
                : "n/a"
            }`,
          );
          lines.push(
            `Preview frontage: ${
              previewData.front_points
                ? JSON.stringify(previewData.front_points)
                : "n/a"
            }`,
          );
        }
        ui.designPreview.textContent = lines.join("\n");
      }

      async function updateDesignPreview(design) {
        if (!design) {
          resetDesignPreview();
          return;
        }
        const cacheKey =
          design.slug || design.id || design.name || design.dxf_url;
        if (appState.designPreviews[cacheKey]) {
          renderDesignPreview(design, appState.designPreviews[cacheKey]);
          return;
        }
        renderDesignPreview(design);
        const filename = getDesignFilename(design);
        if (!filename) return;
        try {
          const preview = await fetchJSON(
            `/files/${encodeURIComponent(filename)}/preview`,
          );
          if (preview) {
            appState.designPreviews[cacheKey] = preview;
            renderDesignPreview(design, preview);
          }
        } catch (err) {
          logMessage(
            "Design preview fetch failed",
            { error: err.message },
            "error",
          );
        }
      }

      function setStatus(message, type = "info") {
        if (!message) {
          statusEl.textContent = "";
          statusEl.classList.add("hidden");
          return;
        }
        statusEl.textContent = message;
        statusEl.classList.remove("hidden");
        statusEl.classList.toggle("error", type === "error");
        console[type === "error" ? "error" : "log"]("[Map status]", message);
      }

      function setDesignStatus(message, type = "info") {
        if (!ui.designStatus) return;
        ui.designStatus.textContent = message || "";
        ui.designStatus.classList.toggle("error", type === "error");
      }

      function updateJobStatus(message, type = "info") {
        if (!ui.jobStatusText) return;
        ui.jobStatusText.textContent = message || "";
        ui.jobStatusText.style.color = type === "error" ? "#d93025" : "#0f172a";
      }

      function updateJobMeta(message) {
        if (!ui.jobMetaText) return;
        ui.jobMetaText.textContent = message || "";
      }

      function setControlsDisabled(disabled) {
        ui.designSelect.disabled = disabled;
        ui.refreshDesignsBtn.disabled = disabled;
        ui.cancelJobBtn.disabled = !disabled;
      }

      function generateLogId() {
        if (
          typeof window !== "undefined" &&
          window.crypto &&
          typeof window.crypto.randomUUID === "function"
        ) {
          return window.crypto.randomUUID();
        }
        return `log-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      window.addEventListener("error", (event) => {
        if (!event?.message) return;
        setStatus(`JS error: ${event.message}`, "error");
      });

      window.addEventListener("unhandledrejection", (event) => {
        const reason =
          event?.reason?.message || event?.reason || "Unknown rejection";
        setStatus(`Promise rejection: ${reason}`, "error");
      });

      function formatTileTemplate(template) {
        return template
          .replace("{z}", "0")
          .replace("{x}", "0")
          .replace("{y}", "0");
      }

      async function sampleTileUrl(styleJSON) {
        const sources = styleJSON?.sources || {};
        for (const source of Object.values(sources)) {
          const tileUrl = await firstTileFromSource(source);
          if (tileUrl) return tileUrl;
        }
        return null;
      }

      async function firstTileFromSource(source) {
        if (!source) return null;

        if (Array.isArray(source.tiles) && source.tiles.length > 0) {
          const template = source.tiles[0];
          if (typeof template === "string") {
            return formatTileTemplate(template);
          }
        }

        if (source.url) {
          try {
            const response = await fetch(source.url);
            if (!response.ok) {
              throw new Error(`TileJSON fetch failed (${response.status})`);
            }
            const tileJSON = await response.json();
            if (Array.isArray(tileJSON.tiles) && tileJSON.tiles.length) {
              return formatTileTemplate(tileJSON.tiles[0]);
            }
          } catch (err) {
            console.error("TileJSON fetch failed", err);
          }
        }

        return null;
      }

      async function verifyTileAccess(styleJSON) {
        const tileUrl = await sampleTileUrl(styleJSON);
        if (!tileUrl) {
          setStatus("No tile URL found in style.", "error");
          return false;
        }

        setStatus("Testing tile access...");
        try {
          const response = await fetch(tileUrl, { method: "HEAD" });
          if (!response.ok) {
            throw new Error(`Tile fetch failed (${response.status})`);
          }
          return true;
        } catch (err) {
          setStatus(`Tile test failed: ${err.message}`, "error");
          return false;
        }
      }

      async function initMap() {
        setStatus("Checking MapTiler style...");
        let styleJSON;
        try {
          const response = await fetch(styleUrl);
          if (!response.ok) {
            throw new Error(`Style fetch failed (${response.status})`);
          }
          styleJSON = await response.json();
        } catch (err) {
          setStatus(`Unable to load style: ${err.message}`, "error");
          return;
        }

        const tileAccessOk = await verifyTileAccess(styleJSON);
        if (!tileAccessOk) {
          console.warn("Continuing without tile access.");
        }

        setStatus("Initializing map...");
        map = new maplibregl.Map({
          container: "map",
          style: styleJSON,
          center: [-84.386, 33.749],
          zoom: 11,
        });

        map.addControl(new maplibregl.NavigationControl(), "top-right");

        let loadTimeout = setTimeout(() => {
          setStatus(
            "Map still loading... check network/API key restrictions.",
            "error",
          );
        }, 7000);

        map.on("load", () => {
          clearTimeout(loadTimeout);
          setStatus("Map style loaded, waiting for tiles...");
          initializeJobLayers();
          initializeOverlaySources();
          attachLongPressHandler();
          map.on("click", handleMapClick);
        });

        map.on("idle", () => {
          setStatus("");
        });

        map.on("error", (event) => {
          const err = event?.error;
          if (!err) return;
          const msg = err.status
            ? `${err.status} ${err.statusText || ""}`.trim()
            : err.message || "Unknown map error";
          setStatus(`Map error: ${msg}`, "error");
        });
      }

      function initializeJobLayers() {
        if (!map || map.getSource(JOB_SOURCE_ID)) return;
        map.addSource(JOB_SOURCE_ID, {
          type: "geojson",
          data: EMPTY_GEOJSON,
        });
        map.addLayer({
          id: JOB_FILL_LAYER_ID,
          type: "fill",
          source: JOB_SOURCE_ID,
          paint: {
            "fill-color": "#4f46e5",
            "fill-opacity": 0.22,
          },
        });
        map.addLayer({
          id: JOB_LINE_LAYER_ID,
          type: "line",
          source: JOB_SOURCE_ID,
          paint: {
            "line-color": "#3730a3",
            "line-width": 2,
          },
        });
      }

      function initializeOverlaySources() {
        if (!map) return;
        if (!map.getSource(PARCEL_BOUNDARY_SOURCE_ID)) {
          map.addSource(PARCEL_BOUNDARY_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PARCEL_BOUNDARY_LAYER_ID,
            type: "line",
            source: PARCEL_BOUNDARY_SOURCE_ID,
            paint: {
              "line-color": "#10b981",
              "line-width": 2,
              "line-dasharray": [2, 2],
            },
          });
        }
        if (!map.getSource(SHADOW_SOURCE_ID)) {
          map.addSource(SHADOW_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: SHADOW_LAYER_ID,
            type: "fill",
            source: SHADOW_SOURCE_ID,
            paint: {
              "fill-color": "#a21caf",
              "fill-opacity": 0.25,
            },
          });
        }
        if (!map.getSource(PLACEMENT_SOURCE_ID)) {
          map.addSource(PLACEMENT_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PLACEMENT_LAYER_ID,
            type: "fill",
            source: PLACEMENT_SOURCE_ID,
            paint: {
              "fill-color": [
                "case",
                ["==", ["get", "isBest"], true],
                "#f97316",
                "#2563eb",
              ],
              "fill-opacity": [
                "case",
                ["==", ["get", "isBest"], true],
                0.5,
                0.2,
              ],
              "fill-outline-color": "#1f2937",
            },
          });
        }
        if (!map.getSource(PLACEMENT_LABEL_SOURCE_ID)) {
          map.addSource(PLACEMENT_LABEL_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PLACEMENT_LABEL_LAYER_ID,
            type: "symbol",
            source: PLACEMENT_LABEL_SOURCE_ID,
            layout: {
              "text-field": [
                "case",
                ["has", "score"],
                ["concat", "Score ", ["get", "score"]],
                "",
              ],
              "text-size": 12,
              "text-anchor": "center",
            },
            paint: {
              "text-color": "#111827",
              "text-halo-color": "#ffffff",
              "text-halo-width": 1,
            },
          });
        }
      }

      function updateJobSource(data) {
        if (!map) return;
        const source = map.getSource(JOB_SOURCE_ID);
        if (source) {
          source.setData(data || EMPTY_GEOJSON);
        }
      }

      function logMessage(message, payload, level = "info") {
        const timestamp = new Date().toLocaleTimeString();
        console[level === "error" ? "error" : "log"](
          `[${timestamp}] ${message}`,
          payload || "",
        );
      }

      function appendEventFeedEntry(entry) {
        if (!ui.eventStreamLog) return;
        appState.eventFeed.push(entry);
        if (appState.eventFeed.length > EVENT_LOG_LIMIT) {
          appState.eventFeed.shift();
        }
        ui.eventStreamLog.textContent = appState.eventFeed.join("\n\n");
      }

      function resetEventFeed() {
        appState.eventFeed = [];
        if (ui.eventStreamLog) {
          ui.eventStreamLog.textContent = "No events yet.";
        }
      }

      function recordCrawlerEventSummary(event, payload) {
        const type = event?.type || event?.event || "event";
        const timestampSource = event?.timestamp || event?.time;
        let timestamp = new Date().toLocaleTimeString();
        if (timestampSource) {
          const date = new Date(timestampSource);
          if (!Number.isNaN(date.getTime())) {
            timestamp = date.toLocaleTimeString();
          }
        }
        const base = {};
        if (event?.parcel_id) base.parcelId = event.parcel_id;
        if (event?.index != null) base.index = event.index;
        if (event?.sequence != null) base.sequence = event.sequence;
        const merged =
          payload && Object.keys(payload).length
            ? { ...base, ...payload }
            : base;
        const content =
          merged && Object.keys(merged).length
            ? `\n${JSON.stringify(merged, null, 2)}`
            : "";
        appendEventFeedEntry(`[${timestamp}] ${type}${content}`);
      }

      async function fetchJSON(path, options = {}) {
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const headers = options.headers ? { ...options.headers } : {};
        if (
          options.body &&
          !(options.body instanceof FormData) &&
          !headers["Content-Type"]
        ) {
          headers["Content-Type"] = "application/json";
        }
        const fetchOptions = { ...options, headers, signal };
        if (!options.signal) {
          appState.abortControllers.add(controller);
        }
        try {
          const response = await fetch(`${API_BASE}${path}`, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          if (response.status === 204) return null;
          return response.json();
        } finally {
          if (!options.signal) {
            appState.abortControllers.delete(controller);
          }
        }
      }

      async function fetchExternalJSON(url, options = {}) {
        if (!url) return null;
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const headers = options.headers ? { ...options.headers } : {};
        const fetchOptions = { ...options, headers, signal };
        appState.abortControllers.add(controller);
        try {
          const response = await fetch(url, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          return response.json();
        } finally {
          appState.abortControllers.delete(controller);
        }
      }

      async function fetchText(path, options = {}) {
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const fetchOptions = { ...options, signal };
        if (!options.signal) {
          appState.abortControllers.add(controller);
        }
        try {
          const response = await fetch(`${API_BASE}${path}`, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          return response.text();
        } finally {
          if (!options.signal) {
            appState.abortControllers.delete(controller);
          }
        }
      }

      async function loadDesigns() {
        setDesignStatus("Loading designs...");
        logMessage("GET /designs");
        try {
          const payload = await fetchJSON("/designs");
          const designs = Array.isArray(payload)
            ? payload
            : payload?.designs || [];
          appState.designs = designs;
          populateDesignSelect();
          setDesignStatus(
            `Loaded ${designs.length} design${designs.length === 1 ? "" : "s"}.`,
          );
          logMessage("Designs loaded", { count: designs.length });
          if (designs.length) {
            updateDesignPreview(designs[0]);
          } else {
            resetDesignPreview();
          }
        } catch (err) {
          console.error(err);
          setDesignStatus(`Failed to load designs: ${err.message}`, "error");
          logMessage("Design load failed", { error: err.message }, "error");
          resetDesignPreview();
        }
      }

      function populateDesignSelect() {
        const select = ui.designSelect;
        if (!select) return;
        const current = select.value;
        select.innerHTML =
          '<option value="">-- Choose a shrink-wrap --</option>';
        appState.designs.forEach((design, index) => {
          const option = document.createElement("option");
          option.value =
            design.slug || design.id || design.name || `design-${index}`;
          option.textContent =
            design.name || design.slug || `Design ${index + 1}`;
          option.dataset.index = index;
          select.appendChild(option);
        });
        select.value =
          current &&
          Array.from(select.options).some((opt) => opt.value === current)
            ? current
            : "";
        handleDesignChange();
      }

      function handleDesignChange() {
        const select = ui.designSelect;
        if (!select) return;
        const option = select.selectedOptions[0];
        if (!option || !option.dataset.index) {
          appState.selectedDesign = null;
          updateJobStatus("Select a design, then click the map.");
          updateJobMeta("");
          resetDesignPreview();
          return;
        }
        const design = appState.designs[Number(option.dataset.index)];
        appState.selectedDesign = design;
        updateJobStatus(
          `"${design.name || "Design"}" ready. Click the map to launch a crawl.`,
        );
        const footprintCount = design?.footprint_points?.length || 0;
        updateJobMeta(
          `${footprintCount} footprint points · Front direction: ${
            design?.front_direction
              ? JSON.stringify(design.front_direction)
              : "auto"
          }`,
        );
        updateDesignPreview(design);
      }

      async function handleMapClick(event) {
        if (suppressNextClick) {
          suppressNextClick = false;
          return;
        }
        if (!appState.selectedDesign) {
          updateJobStatus(
            "Pick a shrink-wrap before launching a crawl.",
            "error",
          );
          return;
        }
        if (appState.job) {
          updateJobStatus(
            "A job is already running. Wait or cancel it first.",
            "error",
          );
          return;
        }
        startJobAtPoint(event.lngLat);
      }

      async function startJobAtPoint(lngLat) {
        const design = appState.selectedDesign;
        if (!design) return;
        setControlsDisabled(true);
        updateJobSource(EMPTY_GEOJSON);
        clearOverlayData();
        resetEventFeed();
        updateJobMeta("");
        updateJobStatus("Preparing job...");
        let address;
        try {
          address = await reverseGeocode(lngLat);
        } catch (err) {
          console.warn(
            "Reverse geocode failed, falling back to raw coordinates.",
            err,
          );
          address = `Lat ${lngLat.lat.toFixed(5)}, Lng ${lngLat.lng.toFixed(5)}`;
        }
        const payload = {
          address,
          dxf_url: design.dxf_url,
          config: {
            target_lat: lngLat.lat,
            target_lon: lngLat.lng,
            cycles: 10,
            score_workers: 4,
            rotation_step: 45,
            full_rotation: false,
            buffer: 20,
            setback: 5,
            auto_front: true,
            front_angle: null,
            auto_offset: false,
            offset_step: 0.5,
            offset_range: 0.5,
            offset_step_scale: 0.2,
            auto_offset_scale: 2.0,
            min_composite: 0.0,
            render_cycle: false,
            render_best: false,
            render_composite: false,
            skip_roads: true,
          },
        };
        if (Array.isArray(design.footprint_points)) {
          payload.footprint_points = design.footprint_points;
        }
        if (Array.isArray(design.front_direction)) {
          payload.front_direction = design.front_direction;
        }
        logMessage("POST /jobs payload", {
          design: design.name,
          lat: lngLat.lat,
          lon: lngLat.lng,
          config: payload.config,
        });
        try {
          const data = await fetchJSON("/jobs", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          appState.job = {
            id: data?.id,
            status: data?.status || "submitted",
            startedAt: Date.now(),
            lngLat,
            designName: design.name || design.slug || "Design",
          };
          logMessage("Job submitted", data);
          placeJobMarker(lngLat);
          updateJobStatus(`Job ${appState.job.id || ""} queued...`);
          updateJobMeta("Waiting for first parcels...");
          scheduleJobPolling();
          startEventStream(appState.job.id);
        } catch (err) {
          console.error(err);
          updateJobStatus(`Failed to start job: ${err.message}`, "error");
          logMessage("Job start failed", { error: err.message }, "error");
          setControlsDisabled(false);
        }
      }

      function placeJobMarker(lngLat) {
        if (appState.jobMarker) {
          appState.jobMarker.remove();
          appState.jobMarker = null;
        }
        if (!map) return;
        appState.jobMarker = new maplibregl.Marker({ color: "#be185d" })
          .setLngLat(lngLat)
          .setPopup(
            new maplibregl.Popup().setHTML("<strong>Job origin</strong>"),
          )
          .addTo(map);
      }

      function clearJobMarker() {
        if (appState.jobMarker) {
          appState.jobMarker.remove();
          appState.jobMarker = null;
        }
      }

      function scheduleJobPolling() {
        clearJobPolling();
        fetchJobStatus();
        fetchJobGeo();
        fetchJobArtifacts();
        appState.pollTimers.status = setInterval(
          fetchJobStatus,
          JOB_STATUS_POLL_MS,
        );
        appState.pollTimers.geo = setInterval(fetchJobGeo, JOB_GEO_POLL_MS);
        appState.pollTimers.artifacts = setInterval(
          fetchJobArtifacts,
          JOB_ARTIFACT_POLL_MS,
        );
      }

      function clearJobPolling() {
        if (appState.pollTimers.status) {
          clearInterval(appState.pollTimers.status);
          appState.pollTimers.status = null;
        }
        if (appState.pollTimers.geo) {
          clearInterval(appState.pollTimers.geo);
          appState.pollTimers.geo = null;
        }
        if (appState.pollTimers.artifacts) {
          clearInterval(appState.pollTimers.artifacts);
          appState.pollTimers.artifacts = null;
        }
      }

      function stopEventStream() {
        const state = appState.eventStreamState;
        if (state?.timer) {
          clearInterval(state.timer);
        }
        appState.eventStreamState = {
          jobId: null,
          timer: null,
          cursor: 0,
          pending: false,
        };
      }

      function startEventStream(jobId) {
        stopEventStream();
        if (!jobId) return;
        const state = {
          jobId,
          timer: null,
          cursor: 0,
          pending: false,
        };
        appState.eventStreamState = state;
        pollCrawlerEvents(jobId);
        state.timer = setInterval(
          () => pollCrawlerEvents(jobId),
          EVENT_POLL_INTERVAL_MS,
        );
      }

      async function pollCrawlerEvents(jobId) {
        const state = appState.eventStreamState;
        if (!state || state.jobId !== jobId || state.pending) return;
        state.pending = true;
        try {
          const params = new URLSearchParams({
            cursor: String(state.cursor || 0),
            max_bytes: String(EVENT_POLL_MAX_BYTES),
          });
          const payload = await fetchJSON(
            `/jobs/${encodeURIComponent(jobId)}/events?${params.toString()}`,
          );
          if (typeof payload?.cursor === "number") {
            state.cursor = payload.cursor;
          }
          if (Array.isArray(payload?.events)) {
            payload.events.forEach((event) => handleCrawlerEvent(event));
          }
          if (payload?.has_more) {
            state.pending = false;
            await pollCrawlerEvents(jobId);
            return;
          }
        } catch (err) {
          const message = err?.message || "";
          if (
            message.includes("Events not available yet") ||
            message.includes("not found")
          ) {
            // waiting for worker to create the log file; ignore quietly
          } else {
            logMessage("Event poll error", { error: message }, "error");
          }
        } finally {
          const latestState = appState.eventStreamState;
          if (latestState && latestState.jobId === jobId) {
            latestState.pending = false;
          }
        }
      }

      function handleCrawlerEvent(line) {
        if (!line) return;
        try {
          const raw =
            typeof line === "string"
              ? JSON.parse(line.trim())
              : typeof line === "object"
                ? line
                : null;
          if (!raw) return;
          const eventType = raw.type || raw.event || raw.kind;
          const payload = raw.payload || raw.data || raw;
          const event = {
            ...raw,
            ...payload,
            type: eventType || raw.type,
            parcel_id: raw.parcel_id ?? payload.parcel_id,
            placement: payload.placement || raw.placement,
            parcel: payload.parcel || raw.parcel,
          };
          logMessage("Crawler event", event);
          if (event.message) {
            updateLogTail(event.message);
          } else if (eventType) {
            updateLogTail(eventType);
          }
          switch (eventType) {
            case "parcel_started":
              handleParcelStartedEvent(event);
              break;
            case "placement_scored":
              handlePlacementScoredEvent(event);
              break;
            case "best_updated":
              handleBestUpdatedEvent(event);
              break;
            case "parcel_completed":
            case "parcel_failed":
              recordCrawlerEventSummary(event);
              requestOverlayRefresh(1000);
              break;
            default:
              break;
          }
        } catch (err) {
          logMessage(
            "Event parse error",
            { line: trimmed, error: err.message },
            "error",
          );
        }
      }

      function handleParcelStartedEvent(event) {
        const parcelData = event.parcel || {
          LOWPARCELID: event.parcel_id,
          geometry: event.geometry,
        };
        if (!parcelData) return;
        const feature = createParcelFeature({ parcel: parcelData });
        if (!feature) return;
        const parcelId = event.parcel_id || feature.properties?.parcelId;
        const parcelKey = parcelId ?? "__unknown__";
        appState.overlayStore.nextPlacementIndex.set(parcelKey, 0);
        upsertParcelFeature(feature, parcelId);
        const summary = {
          area_sqm: parcelData._area_sq_m
            ? Number(parcelData._area_sq_m).toFixed(1)
            : undefined,
          zoning: parcelData.official_zoning || parcelData.zoning_classification,
        };
        recordCrawlerEventSummary(event, summary);
      }

      function handlePlacementScoredEvent(event) {
        const placement =
          event.placement || event.payload || event.data || event;
        if (!placement) return;
        const parcelId =
          event.parcel_id || placement.parcel_id || placement.parcelId;
        const parcelKey = parcelId ?? "__unknown__";
        const placementIndex =
          placement.index ??
          placement.sequence ??
          placement.position ??
          placement.rank ??
          null;
        const feature = createPlacementFeature(placement, parcelId, false);
        if (feature) {
          const nextIndex =
            appState.overlayStore.nextPlacementIndex.get(parcelKey) || 0;
          appState.overlayStore.nextPlacementIndex.set(
            parcelKey,
            nextIndex + 1,
          );
          const key =
            placement.id ||
            placement.placement_id ||
            (placementIndex != null
              ? `${parcelKey}-idx-${placementIndex}`
              : `${parcelKey}-${nextIndex}`);
          upsertPlacementFeature(feature, key);
        }
        const shadowFeature = createShadowFeature(placement, parcelId, false);
        if (shadowFeature) {
          const shadowKey =
            placement.id ||
            `${parcelId || "parcel"}-${placement.sequence || Date.now()}-shadow`;
          upsertShadowFeature(shadowFeature, shadowKey);
        }
        const summary = {
          score: getPlacementCompositeScore(placement),
          rotation_deg: placement.rotation_deg,
          offset: [placement.offset_x_m, placement.offset_y_m],
          sequence: placement.sequence ?? placement.index,
          worker: placement.worker_id,
        };
        recordCrawlerEventSummary(event, summary);
      }

      function handleBestUpdatedEvent(event) {
        const placement =
          event.placement || event.best || event.payload || event;
        if (!placement) return;
        const parcelId =
          event.parcel_id || placement.parcel_id || placement.parcelId;
        const feature = createPlacementFeature(placement, parcelId, true);
        if (feature) {
          upsertBestFeature(feature, parcelId);
        }
        const shadowFeature = createShadowFeature(placement, parcelId, true);
        if (shadowFeature) {
          upsertShadowFeature(
            shadowFeature,
            `${parcelId || "parcel"}-best-shadow`,
          );
        }
        const summary = {
          score: getPlacementCompositeScore(placement),
          rotation_deg: placement.rotation_deg,
          offset: [placement.offset_x_m, placement.offset_y_m],
        };
        recordCrawlerEventSummary(event, summary);
      }

      function isTerminalStatus(status) {
        if (!status) return false;
        const normalized = String(status).toLowerCase();
        return [
          "done",
          "complete",
          "completed",
          "finished",
          "failed",
          "error",
          "cancelled",
          "canceled",
        ].includes(normalized);
      }

      async function fetchJobStatus() {
        if (!appState.job) return;
        try {
          const data = await fetchJSON(
            `/jobs/${encodeURIComponent(appState.job.id)}`,
          );
          const status = data?.status || appState.job.status;
          appState.job.status = status;
          updateJobStatus(`Job ${status}...`);
          if (data?.log_tail) {
            updateLogTail(data.log_tail);
          }
          if (isTerminalStatus(status)) {
            finalizeJob(`Job ${status}.`);
          }
        } catch (err) {
          console.error(err);
          updateJobStatus(`Job status error: ${err.message}`, "error");
        }
      }

      async function fetchJobGeo() {
        if (!appState.job) return;
        logMessage("GET /jobs/{id}/geo", { id: appState.job.id });
        try {
          const data = await fetchJSON(
            `/jobs/${encodeURIComponent(appState.job.id)}/geo`,
          );
          const normalized = normalizeGeoResponse(data);
          if (
            Array.isArray(normalized.features) &&
            normalized.features.length
          ) {
            const collection = convertFeatureCollectionToLngLat(normalized);
            updateJobSource(collection);
            const featureCount = collection.features.length;
            const progress = extractProgress(data);
            if (progress) {
              updateJobMeta(
                `Parcels: ${featureCount} · Progress ${progress.completed ?? "?"}/${progress.total ?? "?"} (${hintsFromProgress(
                  progress,
                )})`,
              );
            } else {
              updateJobMeta(`Parcels returned: ${featureCount}`);
            }
            logMessage("Geo update", { featureCount, progress });
          } else {
            const progress = extractProgress(data);
            if (progress) {
              updateJobMeta(
                `Parcels pending · Progress ${progress.completed ?? "?"}/${progress.total ?? "?"} (${hintsFromProgress(
                  progress,
                )})`,
              );
            } else {
              updateJobMeta("No parcel GeoJSON yet.");
            }
          }
        } catch (err) {
          console.warn("Geo polling error", err);
          updateLogTail(err.message);
          logMessage("Geo polling error", { error: err.message }, "error");
        }
      }

      async function fetchJobArtifacts(jobIdOverride) {
        const jobId = jobIdOverride || appState.job?.id;
        if (!jobId) return;
        logMessage("GET /jobs/{id}/artifacts", { id: jobId });
        try {
          const manifest = await fetchJSON(
            `/jobs/${encodeURIComponent(jobId)}/artifacts`,
          );
          const parcels = manifest?.artifacts?.parcels || [];
          if (!parcels.length) {
            return;
          }
          const urls = parcels
            .map((entry) => normalizeArtifactUrl(entry?.placements_json_url))
            .filter(Boolean);
          if (!urls.length) return;
          // Remove cache entries for parcels no longer referenced
          const cache = appState.overlayCache;
          if (cache.jobId && cache.jobId !== jobId) {
            cache.data = {};
            cache.index = 0;
          }
          cache.jobId = jobId;
          Object.keys(cache.data).forEach((url) => {
            if (!urls.includes(url)) {
              delete cache.data[url];
            }
          });
          const toFetch = urls;
          await Promise.all(
            toFetch.map(async (url) => {
              try {
                const data = await fetchExternalJSON(url, {
                  cache: "no-store",
                });
                if (data) {
                  cache.data[url] = data;
                }
              } catch (err) {
                logMessage(
                  "Placement fetch error",
                  { url, error: err.message },
                  "error",
                );
              }
            }),
          );

          const overlay = buildOverlayFromPlacements(
            Object.values(cache.data).filter(Boolean),
          );
          setOverlayStoreFromCollections(overlay);
        } catch (err) {
          const message = err?.message || "";
          if (message.includes("Artifacts not available yet")) {
            logMessage("Artifact polling pending", { detail: message });
            return;
          }
          console.warn("Artifact polling error", err);
          updateLogTail(err.message);
          logMessage("Artifact polling error", { error: err.message }, "error");
        }
      }
      function normalizeGeoResponse(payload) {
        if (!payload) return EMPTY_GEOJSON;
        if (
          payload.type === "FeatureCollection" &&
          Array.isArray(payload.features)
        ) {
          return payload;
        }
        const features = [];
        const segments =
          payload?.features ||
          payload?.items ||
          payload?.geojson ||
          payload?.data ||
          payload?.collection ||
          payload?.parcels ||
          payload?.queue ||
          [];
        if (Array.isArray(segments)) {
          segments.forEach((item) => {
            if (item?.type === "Feature") {
              features.push(item);
            } else if (item?.geometry) {
              features.push({
                type: "Feature",
                geometry: item.geometry,
                properties: item.properties || {},
              });
            }
          });
        }
        return { type: "FeatureCollection", features };
      }

      function extractProgress(payload) {
        if (!payload) return null;
        const sources = [
          payload.progress,
          payload.properties?.progress,
          payload.metadata?.progress,
          payload.status,
          payload,
        ];
        const found = sources.find(
          (source) =>
            source &&
            (source.completed !== undefined || source.total !== undefined),
        );
        if (!found) return null;
        return {
          completed: found.completed ?? found.done ?? found.current ?? null,
          total: found.total ?? found.expected ?? found.limit ?? null,
          extra: {
            queued: found.queued ?? null,
            remaining: found.remaining ?? null,
            running: found.running ?? null,
          },
        };
      }

      function hintsFromProgress(progress) {
        const hints = [];
        if (progress.extra?.queued)
          hints.push(`${progress.extra.queued} queued`);
        if (progress.extra?.running)
          hints.push(`${progress.extra.running} running`);
        if (progress.extra?.remaining)
          hints.push(`${progress.extra.remaining} remaining`);
        return hints.length ? hints.join(", ") : "no queue";
      }
      function sampleCoordinate(coords) {
        if (!Array.isArray(coords)) return null;
        if (
          coords.length >= 2 &&
          Number.isFinite(coords[0]) &&
          Number.isFinite(coords[1])
        )
          return coords;
        for (const item of coords) {
          const found = sampleCoordinate(item);
          if (found) return found;
        }
        return null;
      }

      function isLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return true;
        return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90;
      }

      function mercatorToLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return coord;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return coord;
        const lng = (x / 20037508.34) * 180;
        let lat = (y / 20037508.34) * 180;
        lat =
          (180 / Math.PI) *
          (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);
        return [lng, lat];
      }

      function convertCoordinates(coords) {
        if (!Array.isArray(coords)) return coords;
        if (coords.length >= 2 && typeof coords[0] === "number") {
          return mercatorToLngLat(coords);
        }
        return coords.map((sub) => convertCoordinates(sub));
      }

      function convertCoordsIfNeeded(coords) {
        if (!Array.isArray(coords)) return coords;
        const sample = sampleCoordinate(coords);
        if (!sample || isLngLat(sample)) return coords;
        return convertCoordinates(coords);
      }

      function boundsToPolygon(bounds) {
        if (!bounds) return null;
        const { xmin, ymin, xmax, ymax } = bounds;
        if (
          [xmin, ymin, xmax, ymax].some(
            (value) => typeof value !== "number" || Number.isNaN(value),
          )
        ) {
          return null;
        }
        return [
          [xmin, ymin],
          [xmax, ymin],
          [xmax, ymax],
          [xmin, ymax],
          [xmin, ymin],
        ];
      }

      function computeCentroid(coords) {
        if (!Array.isArray(coords) || !coords.length) return null;
        const flat = coords.flat(Infinity);
        if (!flat.length) return null;
        const points = [];
        function collect(array) {
          if (array.length >= 2 && typeof array[0] === "number") {
            points.push(array);
          } else {
            array.forEach(collect);
          }
        }
        collect(coords);
        if (!points.length) return null;
        const sum = points.reduce(
          (acc, [x, y]) => {
            acc[0] += x;
            acc[1] += y;
            return acc;
          },
          [0, 0],
        );
        return [sum[0] / points.length, sum[1] / points.length];
      }

      function createFeatureFromCoords(coords, properties = {}) {
        if (!coords) return null;
        const converted = convertCoordsIfNeeded(coords);
        return {
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [converted] },
          properties,
        };
      }

      function updateOverlaySources(data) {
        appState.overlayData = data;
        if (!map) return;
        if (map.getSource(PARCEL_BOUNDARY_SOURCE_ID)) {
          map
            .getSource(PARCEL_BOUNDARY_SOURCE_ID)
            .setData(data.parcels || EMPTY_GEOJSON);
        }
        if (map.getSource(PLACEMENT_SOURCE_ID)) {
          map
            .getSource(PLACEMENT_SOURCE_ID)
            .setData(data.placements || EMPTY_GEOJSON);
        }
        if (map.getSource(SHADOW_SOURCE_ID)) {
          map
            .getSource(SHADOW_SOURCE_ID)
            .setData(data.shadows || EMPTY_GEOJSON);
        }
        if (map.getSource(PLACEMENT_LABEL_SOURCE_ID)) {
          map
            .getSource(PLACEMENT_LABEL_SOURCE_ID)
            .setData(data.labels || EMPTY_GEOJSON);
        }
        const parcelCount = data.parcels?.features?.length || 0;
        const placementCount = data.placements?.features?.length || 0;
        const shadowCount = data.shadows?.features?.length || 0;
        if (ui.parcelSummary) {
          ui.parcelSummary.textContent = `Parcels: ${parcelCount}`;
        }
        if (ui.placementSummary) {
          ui.placementSummary.textContent = `Placements: ${placementCount}`;
        }
        if (ui.shadowSummary) {
          ui.shadowSummary.textContent = `Shadows: ${shadowCount}`;
        }
      }

      function requestOverlayRefresh(delay = 0) {
        if (appState.overlayRefreshPending) return;
        appState.overlayRefreshPending = true;
        setTimeout(() => {
          appState.overlayRefreshPending = false;
          fetchJobArtifacts();
        }, delay);
      }

      function clearOverlayStore() {
        const store = appState.overlayStore;
        store.parcels.clear();
        store.placements.clear();
        store.shadows.clear();
        store.labels.clear();
        store.best.clear();
        store.nextPlacementIndex.clear();
      }

      function renderOverlayFromStore() {
        const store = appState.overlayStore;
        const parcels = Array.from(store.parcels.values());
        const placements = Array.from(store.placements.values());
        const best = Array.from(store.best.values());
        const shadows = Array.from(store.shadows.values());
        const labels = Array.from(store.labels.values());
        updateOverlaySources({
          parcels: {
            type: "FeatureCollection",
            features: parcels,
          },
          placements: {
            type: "FeatureCollection",
            features: placements.concat(best),
          },
          shadows: {
            type: "FeatureCollection",
            features: shadows,
          },
          labels: {
            type: "FeatureCollection",
            features: labels,
          },
        });
      }

      function setOverlayStoreFromCollections(collections) {
        const store = appState.overlayStore;
        const parcelFeatures = collections.parcels?.features || [];
        const shadowFeatures = collections.shadows?.features || [];
        const placementFeatures = collections.placements?.features || [];
        if (
          !parcelFeatures.length &&
          !shadowFeatures.length &&
          !placementFeatures.length
        ) {
          return;
        }
        clearOverlayStore();
        store.nextPlacementIndex.clear();
        parcelFeatures.forEach((feature, index) => {
          const key =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            `parcel-${index}`;
          store.parcels.set(key, feature);
        });
        shadowFeatures.forEach((feature, index) => {
          const key =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            `shadow-${index}`;
          store.shadows.set(key, feature);
        });
        const placementCounts = new Map();
        placementFeatures.forEach((feature, index) => {
          const key =
            feature.properties?.placementKey ||
            feature.properties?.id ||
            `placement-${index}`;
          if (feature.properties?.isBest) {
            const parcelId =
              feature.properties?.parcelId || feature.properties?.id || key;
            store.best.set(parcelId, feature);
          } else {
            store.placements.set(key, feature);
            const parcelIdForCount =
              feature.properties?.parcelId || feature.properties?.id || key;
            const current = placementCounts.get(parcelIdForCount) || 0;
            placementCounts.set(parcelIdForCount, current + 1);
          }
          const label = createLabelFeature(feature);
          if (label) {
            store.labels.set(`${key}-label`, label);
          }
        });
        placementCounts.forEach((count, parcelId) => {
          store.nextPlacementIndex.set(parcelId, count);
        });
        renderOverlayFromStore();
      }

      function upsertParcelFeature(feature, parcelId) {
        if (!feature) return;
        const key =
          parcelId ||
          feature.properties?.parcelId ||
          feature.properties?.id ||
          `parcel-${Date.now()}`;
        appState.overlayStore.parcels.set(key, feature);
        renderOverlayFromStore();
      }

      function upsertPlacementFeature(feature, key) {
        if (!feature) return;
        const placementKey =
          key ||
          feature.properties?.placementKey ||
          `${feature.properties?.parcelId || "parcel"}-${Date.now()}`;
        appState.overlayStore.placements.set(placementKey, feature);
        const label = createLabelFeature(feature);
        if (label) {
          appState.overlayStore.labels.set(`${placementKey}-label`, label);
        }
        renderOverlayFromStore();
      }

      function upsertShadowFeature(feature, key) {
        if (!feature) return;
        const shadowKey = key || `${feature.properties?.parcelId || "shadow"}-${Date.now()}`;
        appState.overlayStore.shadows.set(shadowKey, feature);
        renderOverlayFromStore();
      }

      function upsertBestFeature(feature, parcelId) {
        if (!feature) return;
        const key =
          parcelId ||
          feature.properties?.parcelId ||
          feature.properties?.id ||
          `best-${Date.now()}`;
        appState.overlayStore.best.set(key, feature);
        const label = createLabelFeature(feature);
        if (label) {
          appState.overlayStore.labels.set(`${key}-best-label`, label);
        }
        renderOverlayFromStore();
      }

      function updateLogTail(text) {
        if (!ui.logTail) return;
        ui.logTail.textContent = text || "No log output yet.";
      }

      function clearOverlayData() {
        clearOverlayStore();
        renderOverlayFromStore();
        appState.overlayCache.data = {};
        appState.overlayCache.index = 0;
        appState.overlayCache.jobId = appState.job?.id || null;
      }

      function normalizePolygonGeometry(input) {
        if (!input) return null;
        if (input.type && input.coordinates) {
          return convertGeometryToLngLat(input);
        }
        const converted = convertCoordsIfNeeded(input);
        if (!Array.isArray(converted)) return null;
        const coordinates =
          converted[0] && Array.isArray(converted[0][0])
            ? converted
            : [converted];
        return { type: "Polygon", coordinates };
      }

      function createParcelFeature(data) {
        if (!data?.parcel) return null;
        let geometry =
          normalizePolygonGeometry(
            data.parcel.geometry ||
              data.parcel.polygon ||
              data.parcel.coordinates,
          ) || null;
        if (!geometry) {
          const boundsPolygon = boundsToPolygon(data.parcel._bounds);
          geometry = normalizePolygonGeometry(boundsPolygon);
        }
        if (!geometry) return null;
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId:
              data.parcel.LOWPARCELID ||
              data.parcel.parcel_id ||
              data.summary?.parcel_id,
            address: data.parcel.SITEADDRESS || data.summary?.address,
          },
        };
      }

      function getPlacementCompositeScore(placement) {
        if (!placement) return null;
        const value =
          placement.composite_score ??
          placement.composite ??
          placement.score ??
          placement.score_total ??
          placement.scores?.composite ??
          null;
        if (value == null) return null;
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function createPlacementFeature(placement, parcelId, isBest) {
        const placementIndex =
          placement.index ??
          placement.sequence ??
          placement.position ??
          placement.rank ??
          null;
        const geometry =
          normalizePolygonGeometry(placement.footprint_geojson) ||
          normalizePolygonGeometry(
            placement.footprint_points ||
              placement.footprint ||
              placement.polygon ||
              placement.coordinates,
          );
        if (!geometry) return null;
        const composite = getPlacementCompositeScore(placement);
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId,
            score: composite != null ? Number(composite).toFixed(2) : "n/a",
            rawScore: composite,
            isBest: Boolean(isBest),
            index: placementIndex,
          },
        };
      }

      function createShadowFeature(placement, parcelId, isBest) {
        const geometry =
          normalizePolygonGeometry(placement.shadow_geojson) ||
          normalizePolygonGeometry(
            placement.shadow ||
              placement.shadow_polygon ||
              placement.shadow_outline,
          );
        if (!geometry) return null;
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId,
            isBest: Boolean(isBest),
          },
        };
      }

      function createLabelFeature(feature) {
        if (!feature?.geometry?.coordinates) return null;
        const centroid = computeCentroid(feature.geometry.coordinates);
        if (!centroid) return null;
        const converted = convertCoordsIfNeeded([centroid])[0];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: converted,
          },
          properties: {
            parcelId: feature.properties?.parcelId,
            score: feature.properties?.score,
            isBest: feature.properties?.isBest,
          },
        };
      }

      function buildOverlayFromPlacements(datasets) {
        const parcelFeatures = [];
        const placementFeatures = [];
        const shadowFeatures = [];
        const labelFeatures = [];

        datasets.forEach((dataset) => {
          if (!dataset) return;
          const parcelId =
            dataset.summary?.parcel_id ||
            dataset.parcel?.LOWPARCELID ||
            dataset.parcel?.parcel_id;
          const parcelFeature = createParcelFeature(dataset);
          if (parcelFeature) parcelFeatures.push(parcelFeature);
          const placements = Array.isArray(dataset.placements)
            ? dataset.placements
            : [];
          if (!placements.length) return;
          let bestScore = -Infinity;
          placements.forEach((placement) => {
            const composite = getPlacementCompositeScore(placement);
            if (composite != null && composite > bestScore) {
              bestScore = composite;
            }
          });
          placements.forEach((placement) => {
            const composite = getPlacementCompositeScore(placement);
            const numericScore = composite;
            const isBest =
              bestScore !== -Infinity && !Number.isNaN(numericScore)
                ? numericScore === bestScore
                : false;
            const placementFeature = createPlacementFeature(
              placement,
              parcelId,
              isBest,
            );
            if (placementFeature) {
              placementFeatures.push(placementFeature);
              const labelFeature = createLabelFeature(placementFeature);
              if (labelFeature) labelFeatures.push(labelFeature);
            }
            const shadowFeature = createShadowFeature(
              placement,
              parcelId,
              isBest,
            );
            if (shadowFeature) shadowFeatures.push(shadowFeature);
          });
        });

        return {
          parcels: { type: "FeatureCollection", features: parcelFeatures },
          placements: {
            type: "FeatureCollection",
            features: placementFeatures,
          },
          shadows: { type: "FeatureCollection", features: shadowFeatures },
          labels: { type: "FeatureCollection", features: labelFeatures },
        };
      }

      function sampleCoordinate(coords) {
        if (!Array.isArray(coords)) return null;
        if (
          coords.length >= 2 &&
          Number.isFinite(coords[0]) &&
          Number.isFinite(coords[1])
        ) {
          return coords;
        }
        for (const item of coords) {
          const found = sampleCoordinate(item);
          if (found) return found;
        }
        return null;
      }

      function isLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return true;
        return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90;
      }

      function mercatorToLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return coord;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return coord;
        const lng = (x / 20037508.34) * 180;
        let lat = (y / 20037508.34) * 180;
        lat =
          (180 / Math.PI) *
          (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);
        return [lng, lat];
      }

      function convertCoordinates(coords) {
        if (!Array.isArray(coords)) return coords;
        if (coords.length >= 2 && typeof coords[0] === "number") {
          return mercatorToLngLat(coords);
        }
        return coords.map((sub) => convertCoordinates(sub));
      }

      function convertGeometryToLngLat(geometry) {
        if (!geometry || !geometry.coordinates) return geometry;
        const sample = sampleCoordinate(geometry.coordinates);
        if (!sample || isLngLat(sample)) return geometry;
        return {
          ...geometry,
          coordinates: convertCoordinates(geometry.coordinates),
        };
      }

      function convertFeatureCollectionToLngLat(collection) {
        if (!collection || !Array.isArray(collection.features))
          return collection;
        const features = collection.features.map((feature) => {
          if (!feature?.geometry) return feature;
          return {
            ...feature,
            geometry: convertGeometryToLngLat(feature.geometry),
          };
        });
        return { ...collection, features };
      }

      function finalizeJob(message) {
        const finishedJobId = appState.job?.id;
        clearJobPolling();
        clearJobMarker();
        stopEventStream();
        setControlsDisabled(false);
        ui.cancelJobBtn.disabled = true;
        updateJobStatus(message || "Job finished.");
        logMessage("Job finalized", { message, jobId: finishedJobId });
        appState.job = null;
        fetchJobArtifacts(finishedJobId);
      }

      function abortOngoingApiCalls() {
        appState.abortControllers.forEach((controller) => controller.abort());
        appState.abortControllers.clear();
      }

      function cancelActiveJob(reason, notify = false) {
        if (!appState.job) return;
        const jobId = appState.job.id;
        updateJobStatus(reason || "Job cancelled.", "error");
        updateJobMeta("");
        if (notify && jobId) {
          sendCancellationSignal(jobId, reason);
        }
        clearJobPolling();
        abortOngoingApiCalls();
        clearJobMarker();
        appState.job = null;
        setControlsDisabled(false);
        ui.cancelJobBtn.disabled = true;
        updateJobSource(EMPTY_GEOJSON);
        updateLogTail("");
        clearOverlayData();
        resetEventFeed();
        stopEventStream();
      }

      function sendCancellationSignal(jobId, reason) {
        if (!jobId) return;
        const url = `${API_BASE}/jobs/${encodeURIComponent(jobId)}/cancel`;
        const payload = JSON.stringify({ reason: reason || "client_left" });
        if (navigator.sendBeacon) {
          const blob = new Blob([payload], { type: "application/json" });
          navigator.sendBeacon(url, blob);
        } else {
          fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: payload,
            keepalive: true,
          }).catch(() => {});
        }
      }

      function formatAddress(feature) {
        const p = feature?.properties || {};
        const parts = [
          [p.housenumber, p.street].filter(Boolean).join(" ").trim() || null,
          p.neighbourhood || null,
          p.city || p.town || p.village || null,
          p.state || p.region || null,
          p.postcode || null,
          p.country || null,
        ].filter(Boolean);
        if (parts.length) return parts.join(", ");
        return feature?.place_name || "Address not found";
      }

      async function reverseGeocode(lngLat) {
        const url = `https://api.maptiler.com/geocoding/${lngLat.lng},${lngLat.lat}.json?type=address&limit=1&key=${key}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Reverse geocoding failed");
        const data = await res.json();
        const feature = data.features && data.features[0];
        return formatAddress(feature);
      }

      function showPopup(lngLat, text) {
        new maplibregl.Popup()
          .setLngLat(lngLat)
          .setHTML(
            `<strong>${text}</strong><br>Lat: ${lngLat.lat.toFixed(5)}, Lng: ${lngLat.lng.toFixed(5)}`,
          )
          .addTo(map);
      }

      function attachLongPressHandler() {
        if (!map) return;

        map.on("mousedown", (e) => {
          longPressTimer = setTimeout(async () => {
            longPressCoords = e.lngLat;
            try {
              const address = await reverseGeocode(longPressCoords);
              showPopup(longPressCoords, address);
            } catch (err) {
              setStatus(`Reverse geocode failed: ${err.message}`, "error");
              showPopup(longPressCoords, "Unable to retrieve address");
              console.error(err);
            } finally {
              suppressNextClick = true;
            }
          }, 600);
        });

        map.on("mouseup", () => {
          clearTimeout(longPressTimer);
        });

        map.on("mouseleave", () => {
          clearTimeout(longPressTimer);
        });
      }

      ui.refreshDesignsBtn.addEventListener("click", loadDesigns);
      ui.designSelect.addEventListener("change", handleDesignChange);
      ui.cancelJobBtn.addEventListener("click", () =>
        cancelActiveJob("Job cancelled by user.", true),
      );

      window.addEventListener("beforeunload", () => {
        cancelActiveJob("Page closing. Cancelling crawl.", true);
      });

      function detectMobile() {
        const mobileUA =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent,
          );
        const smallScreen = window.matchMedia("(max-width: 768px)").matches;
        if (mobileUA || smallScreen) {
          document.body.classList.add("mobile-mode");
        }
      }

      detectMobile();
      initMap();
      loadDesigns();
      updateJobStatus("Select a design, then click the map.");
    </script>
  </body>
</html>
