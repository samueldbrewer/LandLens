<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MapTiler Map</title>
  <link href="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.css" rel="stylesheet">
  <script src="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    .status-banner {
      position: absolute;
      background: rgba(255, 255, 255, 0.94);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      font-weight: 600;
      z-index: 1;
    }

    .status-banner {
      top: 12px;
      right: 12px;
      max-width: 280px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .status-banner.error {
      border: 1px solid #d93025;
      color: #d93025;
    }

    .status-banner.hidden {
      display: none;
    }

    .control-panel {
      position: absolute;
      top: 12px;
      left: 12px;
      max-width: 360px;
      width: calc(100% - 160px);
      background: rgba(255, 255, 255, 0.96);
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.15);
      padding: 14px 16px 18px;
      z-index: 2;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .panel-section h1 {
      font-size: 1.2rem;
      margin: 0;
      color: #0f172a;
    }

    .panel-section p {
      margin: 4px 0 0;
      color: #475569;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .panel-section label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #0f172a;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .panel-section select,
    .panel-section button {
      font-family: inherit;
      font-size: 0.95rem;
      border-radius: 8px;
      border: 1px solid #cbd5f5;
      padding: 8px 10px;
    }

    .panel-section select {
      background: #fff;
    }

    .panel-section button {
      border: none;
      background: #2563eb;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .panel-section button:hover {
      background: #1e4fd6;
    }

    .panel-section button:disabled,
    .panel-section select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #0f172a;
    }

    .panel-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .panel-status {
      font-size: 0.85rem;
      color: #475569;
    }

    .panel-status.error {
      color: #d93025;
    }

    .log-section {
      border-top: 1px solid rgba(148, 163, 184, 0.35);
      padding-top: 12px;
    }

    .log-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .log-feed {
      margin-top: 10px;
      max-height: 220px;
      overflow-y: auto;
      background: #0f172a;
      border-radius: 8px;
      padding: 10px;
      color: #e2e8f0;
      font-size: 0.8rem;
      line-height: 1.4;
    }

    .log-entry {
      border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      padding: 6px 0;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-entry strong {
      color: #f8fafc;
      display: block;
    }

    .log-entry pre {
      margin: 4px 0 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: "SFMono-Regular", Consolas, monospace;
      background: rgba(15, 23, 42, 0.7);
      padding: 6px;
      border-radius: 4px;
      color: #cbd5f5;
    }

    .job-status {
      font-weight: 600;
      color: #0f172a;
    }

    .job-meta {
      font-size: 0.85rem;
      color: #475569;
      margin-top: 4px;
    }

    @media (max-width: 640px) {
      .control-panel {
        width: calc(100% - 24px);
      }

      .panel-actions {
        flex-direction: column;
      }

      .panel-section button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="control-panel">
    <div class="panel-section">
      <h1>Land Lens Runner</h1>
      <p>Select a saved shrink-wrap, then click a spot on the map to start a crawl.</p>
    </div>
    <div class="panel-section">
      <label>
        Shrink-wrap design
        <select id="designSelect">
          <option value="">Loading designs…</option>
        </select>
      </label>
      <div class="panel-actions">
        <button id="refreshDesignsBtn" type="button">Refresh designs</button>
      </div>
      <div id="designStatus" class="panel-status"></div>
    </div>
    <div class="panel-section">
      <div id="jobStatusText" class="job-status">Select a design, then click the map.</div>
      <div id="jobMetaText" class="job-meta"></div>
      <div class="panel-actions">
        <button id="cancelJobBtn" class="btn-secondary" type="button" disabled>Cancel active job</button>
      </div>
    </div>
    <div class="panel-section log-section">
      <div class="log-header">
        <div>
          <strong style="color:#0f172a;">Run log</strong>
          <div class="panel-status" style="margin-top:2px;">Latest API payloads & status</div>
        </div>
        <button id="clearLogBtn" class="btn-secondary" type="button" style="padding:6px 10px;font-size:0.8rem;">Clear</button>
      </div>
      <div id="logFeed" class="log-feed">
        <div class="log-entry"><strong>Waiting for activity…</strong></div>
      </div>
    </div>
  </div>
  <div id="status" class="status-banner hidden"></div>
  <div id="map"></div>

  <script>
    const key = "CBo7orMIbQ1XA33zeKV8";
    const styleUrl = `https://api.maptiler.com/maps/streets-v2/style.json?key=${key}`;
    const API_BASE = "https://landlens.up.railway.app";
    const JOB_SOURCE_ID = "job-parcels";
    const JOB_FILL_LAYER_ID = "job-parcels-fill";
    const JOB_LINE_LAYER_ID = "job-parcels-outline";
    const JOB_STATUS_POLL_MS = 5000;
    const JOB_GEO_POLL_MS = 4000;
    const EMPTY_GEOJSON = { type: "FeatureCollection", features: [] };

    maplibregl.workerUrl = "./maplibre-gl-csp-worker.js";
    maplibregl.workerCount = 2;
    let map;
    let longPressTimer;
    let longPressCoords = null;
    let suppressNextClick = false;

    const statusEl = document.getElementById("status");
    const ui = {
      designSelect: document.getElementById("designSelect"),
      designStatus: document.getElementById("designStatus"),
      refreshDesignsBtn: document.getElementById("refreshDesignsBtn"),
      jobStatusText: document.getElementById("jobStatusText"),
      jobMetaText: document.getElementById("jobMetaText"),
      cancelJobBtn: document.getElementById("cancelJobBtn"),
      clearLogBtn: document.getElementById("clearLogBtn"),
      logFeed: document.getElementById("logFeed")
    };

    const appState = {
      designs: [],
      selectedDesign: null,
      job: null,
      pollTimers: { status: null, geo: null },
      abortControllers: new Set(),
      jobMarker: null,
      logs: []
    };
    const LOG_LIMIT = 200;

    function setStatus(message, type = "info") {
      if (!message) {
        statusEl.textContent = "";
        statusEl.classList.add("hidden");
        return;
      }
      statusEl.textContent = message;
      statusEl.classList.remove("hidden");
      statusEl.classList.toggle("error", type === "error");
      console[type === "error" ? "error" : "log"]("[Map status]", message);
    }

    function setDesignStatus(message, type = "info") {
      if (!ui.designStatus) return;
      ui.designStatus.textContent = message || "";
      ui.designStatus.classList.toggle("error", type === "error");
    }

    function updateJobStatus(message, type = "info") {
      if (!ui.jobStatusText) return;
      ui.jobStatusText.textContent = message || "";
      ui.jobStatusText.style.color = type === "error" ? "#d93025" : "#0f172a";
    }

    function updateJobMeta(message) {
      if (!ui.jobMetaText) return;
      ui.jobMetaText.textContent = message || "";
    }

    function setControlsDisabled(disabled) {
      ui.designSelect.disabled = disabled;
      ui.refreshDesignsBtn.disabled = disabled;
      ui.cancelJobBtn.disabled = !disabled;
    }

    function addLogEntry(message, payload, level = "info") {
      const entry = {
        id: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
        timestamp: new Date(),
        message,
        payload,
        level
      };
      appState.logs.unshift(entry);
      if (appState.logs.length > LOG_LIMIT) {
        appState.logs.pop();
      }
      renderLog();
    }

    function formatPayload(payload) {
      if (payload === undefined) return "";
      try {
        return JSON.stringify(payload, null, 2);
      } catch (err) {
        return String(payload);
      }
    }

    function renderLog() {
      if (!ui.logFeed) return;
      if (!appState.logs.length) {
        ui.logFeed.innerHTML = '<div class="log-entry"><strong>No entries yet.</strong></div>';
        return;
      }
      ui.logFeed.innerHTML = appState.logs
        .map((entry) => {
          const time = entry.timestamp.toLocaleTimeString();
          const payloadText = formatPayload(entry.payload);
          return `
            <div class="log-entry">
              <strong>[${time}] ${entry.message}</strong>
              ${payloadText ? `<pre>${payloadText}</pre>` : ""}
            </div>
          `;
        })
        .join("");
    }

    function clearLog() {
      appState.logs = [];
      renderLog();
    }

    window.addEventListener("error", (event) => {
      if (!event?.message) return;
      setStatus(`JS error: ${event.message}`, "error");
    });

    window.addEventListener("unhandledrejection", (event) => {
      const reason = event?.reason?.message || event?.reason || "Unknown rejection";
      setStatus(`Promise rejection: ${reason}`, "error");
    });

    function formatTileTemplate(template) {
      return template
        .replace("{z}", "0")
        .replace("{x}", "0")
        .replace("{y}", "0");
    }

    async function sampleTileUrl(styleJSON) {
      const sources = styleJSON?.sources || {};
      for (const source of Object.values(sources)) {
        const tileUrl = await firstTileFromSource(source);
        if (tileUrl) return tileUrl;
      }
      return null;
    }

    async function firstTileFromSource(source) {
      if (!source) return null;

      if (Array.isArray(source.tiles) && source.tiles.length > 0) {
        const template = source.tiles[0];
        if (typeof template === "string") {
          return formatTileTemplate(template);
        }
      }

      if (source.url) {
        try {
          const response = await fetch(source.url);
          if (!response.ok) {
            throw new Error(`TileJSON fetch failed (${response.status})`);
          }
          const tileJSON = await response.json();
          if (Array.isArray(tileJSON.tiles) && tileJSON.tiles.length) {
            return formatTileTemplate(tileJSON.tiles[0]);
          }
        } catch (err) {
          console.error("TileJSON fetch failed", err);
        }
      }

      return null;
    }

    async function verifyTileAccess(styleJSON) {
      const tileUrl = await sampleTileUrl(styleJSON);
      if (!tileUrl) {
        setStatus("No tile URL found in style.", "error");
        return false;
      }

      setStatus("Testing tile access...");
      try {
        const response = await fetch(tileUrl, { method: "HEAD" });
        if (!response.ok) {
          throw new Error(`Tile fetch failed (${response.status})`);
        }
        return true;
      } catch (err) {
        setStatus(`Tile test failed: ${err.message}`, "error");
        return false;
      }
    }

    async function initMap() {
      setStatus("Checking MapTiler style...");
      let styleJSON;
      try {
        const response = await fetch(styleUrl);
        if (!response.ok) {
          throw new Error(`Style fetch failed (${response.status})`);
        }
        styleJSON = await response.json();
      } catch (err) {
        setStatus(`Unable to load style: ${err.message}`, "error");
        return;
      }

      const tileAccessOk = await verifyTileAccess(styleJSON);
      if (!tileAccessOk) {
        console.warn("Continuing without tile access.");
      }

      setStatus("Initializing map...");
      map = new maplibregl.Map({
        container: "map",
        style: styleJSON,
        center: [0, 0],
        zoom: 3
      });

      map.addControl(new maplibregl.NavigationControl(), "top-right");

      let loadTimeout = setTimeout(() => {
        setStatus("Map still loading... check network/API key restrictions.", "error");
      }, 7000);

      map.on("load", () => {
        clearTimeout(loadTimeout);
        setStatus("Map style loaded, waiting for tiles...");
        initializeJobLayers();
        attachLongPressHandler();
        map.on("click", handleMapClick);
      });

      map.on("idle", () => {
        setStatus("");
      });

      map.on("error", (event) => {
        const err = event?.error;
        if (!err) return;
        const msg = err.status
          ? `${err.status} ${err.statusText || ""}`.trim()
          : err.message || "Unknown map error";
        setStatus(`Map error: ${msg}`, "error");
      });
    }

    function initializeJobLayers() {
      if (!map || map.getSource(JOB_SOURCE_ID)) return;
      map.addSource(JOB_SOURCE_ID, {
        type: "geojson",
        data: EMPTY_GEOJSON
      });
      map.addLayer({
        id: JOB_FILL_LAYER_ID,
        type: "fill",
        source: JOB_SOURCE_ID,
        paint: {
          "fill-color": "#4f46e5",
          "fill-opacity": 0.22
        }
      });
      map.addLayer({
        id: JOB_LINE_LAYER_ID,
        type: "line",
        source: JOB_SOURCE_ID,
        paint: {
          "line-color": "#3730a3",
          "line-width": 2
        }
      });
    }

    function updateJobSource(data) {
      if (!map) return;
      const source = map.getSource(JOB_SOURCE_ID);
      if (source) {
        source.setData(data || EMPTY_GEOJSON);
      }
    }

    async function fetchJSON(path, options = {}) {
      const controller = new AbortController();
      const signal = options.signal || controller.signal;
      const headers = options.headers ? { ...options.headers } : {};
      if (options.body && !(options.body instanceof FormData) && !headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }
      const fetchOptions = { ...options, headers, signal };
      if (!options.signal) {
        appState.abortControllers.add(controller);
      }
      try {
        const response = await fetch(`${API_BASE}${path}`, fetchOptions);
        if (!response.ok) {
          const body = await response.text();
          throw new Error(body || response.statusText || `Request failed (${response.status})`);
        }
        if (response.status === 204) return null;
        return response.json();
      } finally {
        if (!options.signal) {
          appState.abortControllers.delete(controller);
        }
      }
    }

    async function loadDesigns() {
      setDesignStatus("Loading designs...");
      addLogEntry("GET /designs", null);
      try {
        const payload = await fetchJSON("/designs");
        const designs = Array.isArray(payload) ? payload : payload?.designs || [];
        appState.designs = designs;
        populateDesignSelect();
        setDesignStatus(`Loaded ${designs.length} design${designs.length === 1 ? "" : "s"}.`);
        addLogEntry("Designs loaded", designs);
      } catch (err) {
        console.error(err);
        setDesignStatus(`Failed to load designs: ${err.message}`, "error");
        addLogEntry("Design load failed", { error: err.message }, "error");
      }
    }

    function populateDesignSelect() {
      const select = ui.designSelect;
      if (!select) return;
      const current = select.value;
      select.innerHTML = '<option value="">-- Choose a shrink-wrap --</option>';
      appState.designs.forEach((design, index) => {
        const option = document.createElement("option");
        option.value = design.slug || design.id || design.name || `design-${index}`;
        option.textContent = design.name || design.slug || `Design ${index + 1}`;
        option.dataset.index = index;
        select.appendChild(option);
      });
      select.value = current && Array.from(select.options).some((opt) => opt.value === current) ? current : "";
      handleDesignChange();
    }

    function handleDesignChange() {
      const select = ui.designSelect;
      if (!select) return;
      const option = select.selectedOptions[0];
      if (!option || !option.dataset.index) {
        appState.selectedDesign = null;
        updateJobStatus("Select a design, then click the map.");
        updateJobMeta("");
        return;
      }
      const design = appState.designs[Number(option.dataset.index)];
      appState.selectedDesign = design;
      updateJobStatus(`"${design.name || "Design"}" ready. Click the map to launch a crawl.`);
      const footprintCount = design?.footprint_points?.length || 0;
      updateJobMeta(
        `${footprintCount} footprint points · Front direction: ${
          design?.front_direction ? JSON.stringify(design.front_direction) : "auto"
        }`
      );
    }

    async function handleMapClick(event) {
      if (suppressNextClick) {
        suppressNextClick = false;
        return;
      }
      if (!appState.selectedDesign) {
        updateJobStatus("Pick a shrink-wrap before launching a crawl.", "error");
        return;
      }
      if (appState.job) {
        updateJobStatus("A job is already running. Wait or cancel it first.", "error");
        return;
      }
      startJobAtPoint(event.lngLat);
    }

    async function startJobAtPoint(lngLat) {
      const design = appState.selectedDesign;
      if (!design) return;
      setControlsDisabled(true);
      updateJobSource(EMPTY_GEOJSON);
      updateJobMeta("");
      updateJobStatus("Preparing job...");
      let address;
      try {
        address = await reverseGeocode(lngLat);
      } catch (err) {
        console.warn("Reverse geocode failed, falling back to raw coordinates.", err);
        address = `Lat ${lngLat.lat.toFixed(5)}, Lng ${lngLat.lng.toFixed(5)}`;
      }
      const payload = {
        address,
        dxf_url: design.dxf_url,
        config: {
          target_lat: lngLat.lat,
          target_lon: lngLat.lng
        }
      };
      if (Array.isArray(design.footprint_points)) {
        payload.footprint_points = design.footprint_points;
      }
      if (Array.isArray(design.front_direction)) {
        payload.front_direction = design.front_direction;
      }
      addLogEntry("POST /jobs payload", payload);
      try {
        const data = await fetchJSON("/jobs", {
          method: "POST",
          body: JSON.stringify(payload)
        });
        appState.job = {
          id: data?.id,
          status: data?.status || "submitted",
          startedAt: Date.now(),
          lngLat,
          designName: design.name || design.slug || "Design"
        };
        addLogEntry("Job submitted", data);
        placeJobMarker(lngLat);
        updateJobStatus(`Job ${appState.job.id || ""} queued...`);
        updateJobMeta("Waiting for first parcels...");
        scheduleJobPolling();
      } catch (err) {
        console.error(err);
        updateJobStatus(`Failed to start job: ${err.message}`, "error");
        addLogEntry("Job start failed", { error: err.message }, "error");
        setControlsDisabled(false);
      }
    }

    function placeJobMarker(lngLat) {
      if (appState.jobMarker) {
        appState.jobMarker.remove();
        appState.jobMarker = null;
      }
      if (!map) return;
      appState.jobMarker = new maplibregl.Marker({ color: "#be185d" })
        .setLngLat(lngLat)
        .setPopup(new maplibregl.Popup().setHTML("<strong>Job origin</strong>"))
        .addTo(map);
    }

    function clearJobMarker() {
      if (appState.jobMarker) {
        appState.jobMarker.remove();
        appState.jobMarker = null;
      }
    }

    function scheduleJobPolling() {
      clearJobPolling();
      fetchJobStatus();
      fetchJobGeo();
      appState.pollTimers.status = setInterval(fetchJobStatus, JOB_STATUS_POLL_MS);
      appState.pollTimers.geo = setInterval(fetchJobGeo, JOB_GEO_POLL_MS);
    }

    function clearJobPolling() {
      if (appState.pollTimers.status) {
        clearInterval(appState.pollTimers.status);
        appState.pollTimers.status = null;
      }
      if (appState.pollTimers.geo) {
        clearInterval(appState.pollTimers.geo);
        appState.pollTimers.geo = null;
      }
    }

    function isTerminalStatus(status) {
      if (!status) return false;
      const normalized = String(status).toLowerCase();
      return ["done", "complete", "completed", "finished", "failed", "error", "cancelled", "canceled"].includes(normalized);
    }

    async function fetchJobStatus() {
      if (!appState.job) return;
      addLogEntry("GET /jobs/{id}", { id: appState.job.id });
      try {
        const data = await fetchJSON(`/jobs/${encodeURIComponent(appState.job.id)}`);
        const status = data?.status || appState.job.status;
        appState.job.status = status;
        updateJobStatus(`Job ${status}...`);
        addLogEntry("Job status response", data);
        if (isTerminalStatus(status)) {
          finalizeJob(`Job ${status}.`);
        }
      } catch (err) {
        console.error(err);
        updateJobStatus(`Job status error: ${err.message}`, "error");
        addLogEntry("Job status error", { error: err.message }, "error");
      }
    }

    async function fetchJobGeo() {
      if (!appState.job) return;
      addLogEntry("GET /jobs/{id}/geo", { id: appState.job.id });
      try {
        const data = await fetchJSON(`/jobs/${encodeURIComponent(appState.job.id)}/geo`);
        const collection = normalizeGeoResponse(data);
        updateJobSource(collection);
        const featureCount = Array.isArray(collection.features) ? collection.features.length : 0;
        const progress = extractProgress(data);
        if (progress) {
          updateJobMeta(
            `Parcels: ${featureCount} · Progress ${progress.completed ?? "?"}/${progress.total ?? "?"} (${hintsFromProgress(
              progress
            )})`
          );
        } else {
          updateJobMeta(`Parcels returned: ${featureCount}`);
        }
        addLogEntry("Geo update", { featureCount, progress });
      } catch (err) {
        console.warn("Geo polling error", err);
        addLogEntry("Geo polling error", { error: err.message }, "error");
      }
    }

    function normalizeGeoResponse(payload) {
      if (!payload) return EMPTY_GEOJSON;
      if (payload.type === "FeatureCollection" && Array.isArray(payload.features)) {
        return payload;
      }
      const features = [];
      const segments =
        payload?.features ||
        payload?.items ||
        payload?.geojson ||
        payload?.data ||
        payload?.collection ||
        payload?.parcels ||
        payload?.queue ||
        [];
      if (Array.isArray(segments)) {
        segments.forEach((item) => {
          if (item?.type === "Feature") {
            features.push(item);
          } else if (item?.geometry) {
            features.push({
              type: "Feature",
              geometry: item.geometry,
              properties: item.properties || {}
            });
          }
        });
      }
      return { type: "FeatureCollection", features };
    }

    function extractProgress(payload) {
      if (!payload) return null;
      const sources = [
        payload.progress,
        payload.properties?.progress,
        payload.metadata?.progress,
        payload.status,
        payload
      ];
      const found = sources.find((source) => source && (source.completed !== undefined || source.total !== undefined));
      if (!found) return null;
      return {
        completed: found.completed ?? found.done ?? found.current ?? null,
        total: found.total ?? found.expected ?? found.limit ?? null,
        extra: {
          queued: found.queued ?? null,
          remaining: found.remaining ?? null,
          running: found.running ?? null
        }
      };
    }

    function hintsFromProgress(progress) {
      const hints = [];
      if (progress.extra?.queued) hints.push(`${progress.extra.queued} queued`);
      if (progress.extra?.running) hints.push(`${progress.extra.running} running`);
      if (progress.extra?.remaining) hints.push(`${progress.extra.remaining} remaining`);
      return hints.length ? hints.join(", ") : "no queue";
    }
        if (data?.type === "FeatureCollection") {
          updateJobSource(data);
          const featureCount = Array.isArray(data.features) ? data.features.length : 0;
          const progress =
            data?.properties?.progress ||
            data?.metadata?.progress ||
            data?.progress ||
            null;
          if (progress && typeof progress === "object") {
            updateJobMeta(
              `Parcels: ${featureCount} · Progress ${progress.completed ?? progress.done ?? "?"}/${
                progress.total ?? progress.expected ?? "?"
              }`
            );
          } else {
            updateJobMeta(`Parcels returned: ${featureCount}`);
          }
          addLogEntry("Geo update", { featureCount, progress });
        }
      } catch (err) {
        console.warn("Geo polling error", err);
        addLogEntry("Geo polling error", { error: err.message }, "error");
      }
    }

    function finalizeJob(message) {
      clearJobPolling();
      abortOngoingApiCalls();
      clearJobMarker();
      setControlsDisabled(false);
      ui.cancelJobBtn.disabled = true;
      updateJobStatus(message || "Job finished.");
      addLogEntry("Job finalized", { message });
      appState.job = null;
    }

    function abortOngoingApiCalls() {
      appState.abortControllers.forEach((controller) => controller.abort());
      appState.abortControllers.clear();
    }

    function cancelActiveJob(reason, notify = false) {
      if (!appState.job) return;
      const jobId = appState.job.id;
      updateJobStatus(reason || "Job cancelled.", "error");
      updateJobMeta("");
      addLogEntry("Job cancelled", { reason, notify });
      if (notify && jobId) {
        sendCancellationSignal(jobId, reason);
      }
      clearJobPolling();
      abortOngoingApiCalls();
      clearJobMarker();
      appState.job = null;
      setControlsDisabled(false);
      ui.cancelJobBtn.disabled = true;
      updateJobSource(EMPTY_GEOJSON);
    }

    function sendCancellationSignal(jobId, reason) {
      if (!jobId) return;
      const url = `${API_BASE}/jobs/${encodeURIComponent(jobId)}/cancel`;
      const payload = JSON.stringify({ reason: reason || "client_left" });
      addLogEntry("POST /jobs/{id}/cancel", { jobId, reason });
      if (navigator.sendBeacon) {
        const blob = new Blob([payload], { type: "application/json" });
        navigator.sendBeacon(url, blob);
      } else {
        fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: payload,
          keepalive: true
        }).catch(() => {});
      }
    }

    function formatAddress(feature) {
      const p = feature?.properties || {};
      const parts = [
        [p.housenumber, p.street].filter(Boolean).join(" ").trim() || null,
        p.neighbourhood || null,
        p.city || p.town || p.village || null,
        p.state || p.region || null,
        p.postcode || null,
        p.country || null
      ].filter(Boolean);
      if (parts.length) return parts.join(", ");
      return feature?.place_name || "Address not found";
    }

    async function reverseGeocode(lngLat) {
      const url = `https://api.maptiler.com/geocoding/${lngLat.lng},${lngLat.lat}.json?type=address&limit=1&key=${key}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Reverse geocoding failed");
      const data = await res.json();
      const feature = data.features && data.features[0];
      return formatAddress(feature);
    }

    function showPopup(lngLat, text) {
      new maplibregl.Popup()
        .setLngLat(lngLat)
        .setHTML(`<strong>${text}</strong><br>Lat: ${lngLat.lat.toFixed(5)}, Lng: ${lngLat.lng.toFixed(5)}`)
        .addTo(map);
    }

    function attachLongPressHandler() {
      if (!map) return;

      map.on("mousedown", (e) => {
        longPressTimer = setTimeout(async () => {
          longPressCoords = e.lngLat;
          try {
            const address = await reverseGeocode(longPressCoords);
            showPopup(longPressCoords, address);
          } catch (err) {
            setStatus(`Reverse geocode failed: ${err.message}`, "error");
            showPopup(longPressCoords, "Unable to retrieve address");
            console.error(err);
          } finally {
            suppressNextClick = true;
          }
        }, 600);
      });

      map.on("mouseup", () => {
        clearTimeout(longPressTimer);
      });

      map.on("mouseleave", () => {
        clearTimeout(longPressTimer);
      });
    }

    ui.refreshDesignsBtn.addEventListener("click", loadDesigns);
    ui.designSelect.addEventListener("change", handleDesignChange);
    ui.cancelJobBtn.addEventListener("click", () => cancelActiveJob("Job cancelled by user.", true));
    if (ui.clearLogBtn) {
      ui.clearLogBtn.addEventListener("click", clearLog);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        cancelActiveJob("Page hidden. Stopping crawl.", true);
      }
    });

    window.addEventListener("beforeunload", () => {
      cancelActiveJob("Page closing. Cancelling crawl.", true);
    });

    renderLog();
    initMap();
    loadDesigns();
    updateJobStatus("Select a design, then click the map.");
  </script>
</body>
</html>
