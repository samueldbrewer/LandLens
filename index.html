<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MapTiler Map</title>
    <link
      href="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://cdn.maptiler.com/maplibre-gl-js/v2.4.0/maplibre-gl.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
      }

      #map {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      .status-banner {
        position: absolute;
        background: rgba(255, 255, 255, 0.94);
        padding: 8px 12px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        font-weight: 600;
        z-index: 1;
      }

      .status-banner {
        top: 12px;
        right: 12px;
        max-width: 280px;
        font-size: 0.85rem;
        font-weight: 500;
      }

      .status-banner.error {
        border: 1px solid #d93025;
        color: #d93025;
      }

      .status-banner.hidden {
        display: none;
      }

      body.mobile-mode .desktop-only {
        display: none !important;
      }

      body:not(.mobile-mode) .mobile-only {
        display: none !important;
      }

      body.mobile-mode .control-panel {
        display: none !important;
      }

      .control-panel {
        position: absolute;
        top: 20px;
        bottom: 20px;
        left: 20px;
        width: 420px;
        background: #f9fafb;
        border-radius: 22px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.2);
        padding: 22px;
        z-index: 2;
        display: flex;
        flex-direction: column;
        gap: 18px;
        color: #0f172a;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .panel-section h1 {
        font-size: 1.35rem;
        margin: 0;
        color: #0f172a;
      }

      .panel-section p {
        margin: 4px 0 0;
        color: #475569;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      .panel-section label {
        font-size: 0.9rem;
        font-weight: 600;
        color: #0f172a;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .panel-section select,
      .panel-section button {
        font-family: inherit;
        font-size: 0.95rem;
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        padding: 8px 10px;
      }

      .panel-section select {
        background: #fff;
        display: none;
      }

      .panel-section button {
        border: none;
        background: #1d4ed8;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.15s ease;
        box-shadow: none;
      }

      .panel-section button:hover {
        background: #0f62fe;
      }

      .panel-section button:disabled,
      .panel-section select:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .job-control-btn {
        min-width: 120px;
        display: none;
        border-radius: 999px;
        padding: 8px 18px;
        font-weight: 600;
        border: 1px solid transparent;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .job-control-btn:active {
        transform: translateY(1px);
      }

      .job-control-btn.btn-stop {
        background: #fef3c7;
        border-color: #facc15;
        color: #92400e;
        box-shadow: 0 6px 16px rgba(250, 204, 21, 0.3);
      }

      .job-control-btn.btn-stop:hover {
        background: #fde68a;
      }

      .job-control-btn.btn-clear {
        background: #fee2e2;
        border-color: #fecaca;
        color: #991b1b;
        box-shadow: 0 6px 16px rgba(248, 113, 113, 0.25);
      }

      .job-control-btn.btn-clear:hover {
        background: #fecaca;
      }

      .mobile-cancel {
        width: 100%;
        margin-top: 8px;
        border-radius: 999px;
        padding: 10px 14px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
      }

      .mobile-bar {
        position: absolute;
        top: 12px;
        left: 12px;
        right: 12px;
        z-index: 3;
      }

      .mobile-bar button {
        width: 100%;
        padding: 10px 14px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: #ffffff;
        color: #0f172a;
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
      }

      .mobile-design-menu {
        position: absolute;
        top: 64px;
        left: 12px;
        right: 12px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 14px;
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
        max-height: 60vh;
        overflow-y: auto;
        padding: 10px;
        z-index: 3;
      }

      .mobile-design-menu.hidden {
        display: none;
      }

      button.mobile-design-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid #dbe5ff;
        background: #f4f7ff;
        margin-bottom: 8px;
        width: 100%;
        text-align: left;
        color: #0f172a;
      }

      button.mobile-design-row:last-child {
        margin-bottom: 0;
      }

      .design-thumb {
        width: 72px;
        height: 72px;
        border-radius: 10px;
        border: 1px solid rgba(15, 23, 42, 0.1);
        background: #f8fafc;
      }

      .mobile-design-info {
        flex: 1;
      }

      .mobile-design-info strong {
        display: block;
        color: inherit;
      }

      .mobile-design-info span {
        color: inherit;
        font-size: 0.85rem;
      }

      button.mobile-design-row.active {
        border-color: #0f62fe;
        background: #0f62fe;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
        color: #ffffff;
      }

      .mobile-leaderboard {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 3;
        transition: transform 0.25s ease, height 0.25s ease;
      }

      .leaderboard-shell {
        margin: 0 auto;
        width: calc(100% - 24px);
        max-width: 560px;
        background: #ffffff;
        border-radius: 18px 18px 0 0;
        color: #0f172a;
        box-shadow: 0 -12px 30px rgba(15, 23, 42, 0.2);
        padding: 12px 16px 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
      }

      .leaderboard-handle {
        width: 46px;
        height: 4px;
        border-radius: 999px;
        background: #cbd5f5;
        margin: 0 auto 10px;
      }

      .leaderboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .leaderboard-list {
        margin: 12px 0 0;
        max-height: 240px;
        overflow-y: auto;
      }

      .leaderboard-row {
        width: 100%;
        padding: 10px 12px;
        border: none;
        border-radius: 10px;
        background: #edf2ff;
        color: inherit;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .leaderboard-row.active {
        background: #dae6ff;
      }

      .leaderboard-row-score {
        font-weight: 700;
        color: #0f172a;
      }


      .leaderboard-detail {
        margin-top: 12px;
        background: #ffffff;
        border-radius: 12px;
        padding: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        max-height: 220px;
        overflow-y: auto;
        color: #0f172a;
      }

      .design-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      button.desktop-design-row {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 12px;
        border-radius: 14px;
        border: 1px solid #dbe5ff;
        background: #f4f7ff;
        cursor: pointer;
        transition: box-shadow 0.2s ease, border-color 0.2s ease;
        color: #0f172a;
      }

      button.desktop-design-row.active {
        border-color: #0f62fe;
        background: #0f62fe;
        box-shadow: 0 14px 30px rgba(15, 23, 42, 0.25);
        color: #ffffff;
      }

      button.desktop-design-row .design-thumb {
        width: 110px;
        height: 80px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: #f8fafc;
      }

      button.desktop-design-row strong {
        display: block;
        font-size: 0.98rem;
      }

      button.desktop-design-row span {
        color: #475569;
        font-size: 0.85rem;
      }

      button.desktop-design-row.active strong,
      button.desktop-design-row.active span,
      button.mobile-design-row.active .mobile-design-info strong,
      button.mobile-design-row.active .mobile-design-info span {
        color: #ffffff;
      }

      button.mobile-design-row.active .design-thumb,
      button.desktop-design-row.active .design-thumb {
        border-color: rgba(255, 255, 255, 0.6);
      }

      .mobile-leaderboard.collapsed .leaderboard-content {
        display: none;
      }

      .parcel-popup {
        font-size: 0.85rem;
        color: #0f172a;
        min-width: 220px;
      }

      .parcel-popup h3 {
        margin: 0 0 6px;
        font-size: 1rem;
        color: #0f172a;
      }

      .parcel-popup .parcel-popup-meta {
        margin: 2px 0;
      }

      .parcel-popup a {
        color: #2563eb;
        text-decoration: none;
      }

      .leaderboard-detail .parcel-popup,
      .leaderboard-detail .parcel-popup h3,
      .leaderboard-detail .parcel-popup .parcel-popup-meta {
        color: #0f172a;
      }

      .leaderboard-detail .parcel-popup a {
        color: #2563eb;
      }


      .desktop-leaderboard-flyout {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 320px;
        opacity: 0;
        pointer-events: none;
        transform: translateY(10px);
        transition: opacity 0.25s ease, transform 0.25s ease;
        z-index: 3;
      }

      .desktop-leaderboard-flyout.visible {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      .desktop-leaderboard-card {
        background: #ffffff;
        border-radius: 20px;
        padding: 16px;
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.18);
        color: #0f172a;
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      .desktop-leaderboard-card .leaderboard-header strong {
        color: #0f172a;
      }

      .desktop-leaderboard-card .leaderboard-list {
        max-height: 220px;
      }

      .desktop-leaderboard-card .leaderboard-row {
        background: #edf2ff;
        color: #0f172a;
      }

      .desktop-leaderboard-card .leaderboard-row.active {
        background: #dae6ff;
      }

      .desktop-leaderboard-card .leaderboard-row-score {
        color: #0f172a;
      }

      @media (max-width: 768px) {
        .desktop-leaderboard-flyout {
          display: none !important;
        }
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #0f172a;
      }

      .panel-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .panel-status {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.85);
      }

      .panel-status.error {
        color: #d93025;
      }

      .log-section {
        border-top: 1px solid rgba(148, 163, 184, 0.35);
        padding-top: 12px;
      }

      .log-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .log-feed {
        margin-top: 10px;
        max-height: 320px;
        overflow-y: auto;
        background: #0f172a;
        border-radius: 8px;
        padding: 10px;
        color: #e2e8f0;
        font-size: 0.8rem;
        line-height: 1.4;
      }

      .log-entry {
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        padding: 6px 0;
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry strong {
        color: #f8fafc;
        display: block;
      }

      .log-entry pre {
        margin: 4px 0 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "SFMono-Regular", Consolas, monospace;
        background: rgba(15, 23, 42, 0.7);
        padding: 6px;
        border-radius: 4px;
        color: #cbd5f5;
      }

      .parcel-info {
        background: #fff;
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 10px;
        padding: 12px;
        font-size: 0.9rem;
        color: #0f172a;
        max-height: 220px;
        overflow-y: auto;
      }

      .parcel-info .label {
        font-weight: 600;
        color: #475569;
      }

      .job-status {
        font-weight: 600;
        color: #0f172a;
      }

      .job-meta {
        font-size: 0.9rem;
        color: #475569;
        margin-top: 4px;
      }


      @media (max-width: 640px) {
        .control-panel {
          width: calc(100% - 24px);
          left: 12px;
          right: 12px;
          top: auto;
          bottom: 12px;
        }

        .panel-actions {
          flex-direction: column;
        }

        .panel-section button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="control-panel">
      <div class="panel-section">
        <h1>Select a design and long press to start a crawl.</h1>
      </div>
      <div class="panel-section mobile-only">
        <p style="margin: 0; color: #475569; font-size: 0.9rem">
          Tap anywhere on the map after picking a design. We'll stream results
          below.
        </p>
      </div>
      <div class="panel-section" id="designChooser">
        <div style="display: flex; justify-content: space-between; align-items: center">
          <strong>Designs</strong>
          <button id="refreshDesignsBtn" type="button" style="width: auto; padding: 6px 12px">
            Refresh
          </button>
        </div>
        <div id="designStatus" class="panel-status" style="margin-bottom: 8px"></div>
        <div id="desktopDesignList" class="design-list"></div>
        <select id="designSelect" class="visually-hidden">
          <option value="">Loading designs…</option>
        </select>
      </div>
      <div class="panel-section">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 8px">
          <div>
            <div id="jobStatusText" class="job-status">
              Select a design, then click the map.
            </div>
            <div id="jobMetaText" class="job-meta"></div>
          </div>
          <button
            id="cancelJobBtn"
            class="job-control-btn"
            type="button"
            disabled
          >
            Stop job
          </button>
        </div>
      </div>
      <div class="panel-section panel-log desktop-only">
        <strong>Live activity</strong>
        <div id="statusFeed" class="status-feed">
          <div class="status-item muted">
            <div class="status-dot"></div>
            <div>
              <div class="status-message">No activity yet.</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="mobile-only">
      <div class="mobile-bar">
        <button id="mobileDesignToggle" type="button">
          <span>Select design</span>
          <strong id="mobileDesignCurrent">Choose…</strong>
        </button>
        <button
          id="mobileCancelBtn"
          type="button"
          class="job-control-btn mobile-cancel"
        >
          Stop job
        </button>
      </div>
      <div id="mobileDesignMenu" class="mobile-design-menu hidden">
        <div id="mobileDesignList"></div>
      </div>
    </div>
    <div id="status" class="status-banner hidden"></div>
    <div id="map"></div>
    <div id="leaderboardTray" class="mobile-leaderboard mobile-only collapsed">
      <div class="leaderboard-shell" id="leaderboardCard">
        <div class="leaderboard-handle"></div>
        <div class="leaderboard-header">
          <strong>Top parcels</strong>
          <button id="leaderboardToggle" type="button" class="btn-secondary">
            View
          </button>
        </div>
        <div class="leaderboard-content" id="leaderboardContent">
          <div class="leaderboard-list" id="leaderboardList"></div>
          <div class="leaderboard-detail" id="leaderboardDetail">
            Placements will appear here during a crawl.
          </div>
        </div>
      </div>
    </div>
    <div id="desktopLeaderboardFlyout" class="desktop-leaderboard-flyout">
      <div class="desktop-leaderboard-card">
        <div class="leaderboard-header" style="margin-bottom: 8px">
          <strong>Top parcels</strong>
        </div>
        <div class="leaderboard-list" id="desktopFlyoutList"></div>
        <div class="leaderboard-detail" id="desktopFlyoutDetail">
          Placements will appear here during a crawl.
        </div>
      </div>
    </div>

    <script>
      const key = "CBo7orMIbQ1XA33zeKV8";
      const styleUrl = `https://api.maptiler.com/maps/hybrid/style.json?key=${key}`;
      const API_BASE = "https://landlens.up.railway.app";
      const JOB_SOURCE_ID = "job-parcels";
      const JOB_FILL_LAYER_ID = "job-parcels-fill";
      const JOB_LINE_LAYER_ID = "job-parcels-outline";
      const PARCEL_BOUNDARY_SOURCE_ID = "parcel-boundaries";
      const PARCEL_FILL_LAYER_ID = "parcel-boundaries-fill";
      const PARCEL_BOUNDARY_LAYER_ID = "parcel-boundaries-outline";
      const PARCEL_BOUNDARY_SELECTED_LAYER_ID = "parcel-boundaries-outline-selected";
      const PLACEMENT_SOURCE_ID = "parcel-placements";
      const PLACEMENT_LAYER_ID = "parcel-placements-fill";
      const SHADOW_SOURCE_ID = "parcel-shadows";
      const SHADOW_LAYER_ID = "parcel-shadows-fill";
      const PLACEMENT_LABEL_SOURCE_ID = "placement-labels";
      const PLACEMENT_LABEL_LAYER_ID = "placement-labels-symbol";
      const JOB_STATUS_POLL_MS = 5000;
      const JOB_GEO_POLL_MS = 4000;
      const EVENT_POLL_INTERVAL_MS = 1500;
      const EVENT_POLL_MAX_BYTES = 200000;
      const EVENT_LOG_LIMIT = 200;
      const STATUS_FEED_LIMIT = 8;
      const EMPTY_GEOJSON = { type: "FeatureCollection", features: [] };

      maplibregl.workerUrl = "./maplibre-gl-csp-worker.js";
      maplibregl.workerCount = 2;
      let map;
      let longPressTimer;
      let longPressCoords = null;
      let suppressNextClick = false;
      let addressPopup = null;

      const statusEl = document.getElementById("status");
      const ui = {
        designSelect: document.getElementById("designSelect"),
        designStatus: document.getElementById("designStatus"),
        refreshDesignsBtn: document.getElementById("refreshDesignsBtn"),
        jobStatusText: document.getElementById("jobStatusText"),
        jobMetaText: document.getElementById("jobMetaText"),
        cancelJobBtn: document.getElementById("cancelJobBtn"),
        parcelSummary: document.getElementById("parcelSummary"),
        placementSummary: document.getElementById("placementSummary"),
        shadowSummary: document.getElementById("shadowSummary"),
        statusFeed: document.getElementById("statusFeed"),
        desktopDesignList: document.getElementById("desktopDesignList"),
        mobileDesignToggle: document.getElementById("mobileDesignToggle"),
        mobileDesignMenu: document.getElementById("mobileDesignMenu"),
        mobileDesignList: document.getElementById("mobileDesignList"),
        mobileDesignCurrent: document.getElementById("mobileDesignCurrent"),
        mobileCancelBtn: document.getElementById("mobileCancelBtn"),
        leaderboardTray: document.getElementById("leaderboardTray"),
        leaderboardToggle: document.getElementById("leaderboardToggle"),
        leaderboardList: document.getElementById("leaderboardList"),
        leaderboardDetail: document.getElementById("leaderboardDetail"),
        leaderboardContent: document.getElementById("leaderboardContent"),
        desktopLeaderboardFlyout: document.getElementById(
          "desktopLeaderboardFlyout",
        ),
        desktopFlyoutList: document.getElementById("desktopFlyoutList"),
        desktopFlyoutDetail: document.getElementById("desktopFlyoutDetail"),
      };

      const appState = {
        designs: [],
        selectedDesign: null,
        selectedDesignIndex: null,
        job: null,
        selectedParcelId: null,
        mobileDesignMenuOpen: false,
        leaderboardOpen: false,
        jobControlState: "hidden",
        pollTimers: { status: null, geo: null },
        abortControllers: new Set(),
        jobMarker: null,
        overlayCache: {
          data: {},
          index: 0,
          jobId: null,
        },
        overlayData: {
          parcels: EMPTY_GEOJSON,
          placements: EMPTY_GEOJSON,
          shadows: EMPTY_GEOJSON,
          labels: EMPTY_GEOJSON,
        },
        designPreviews: {},
        eventStreamState: {
          jobId: null,
          timer: null,
          cursor: 0,
          pending: false,
        },
        overlayRefreshPending: false,
        parcelLayerHandlersBound: false,
        parcelArtifactIndex: {},
        parcelPopup: null,
        activeParcelPopupId: null,
        leaderboardEntries: [],
        leaderboardSelectedId: null,
        statusFeedMessage: "No activity yet.",
        overlayStore: {
          parcels: new Map(),
          placements: new Map(),
          shadows: new Map(),
          labels: new Map(),
          best: new Map(),
          nextPlacementIndex: new Map(),
          parcelDetails: new Map(),
        },
        eventFeed: [],
      };

      setJobControlState(appState.jobControlState);

      function getDesignFilename(design) {
        const url = design?.dxf_url;
        if (!url) return null;
        try {
          if (url.startsWith("file://")) {
            const path = url.replace("file://", "");
            const parts = path.split("/").filter(Boolean);
            return parts.pop();
          }
          const parsed = new URL(url);
          const segments = parsed.pathname.split("/").filter(Boolean);
          return segments.pop();
        } catch (err) {
          return null;
        }
      }

      function normalizeArtifactUrl(url) {
        if (!url) return null;
        try {
          if (url.startsWith("/")) return url;
          if (url.startsWith("http://landlens.up.railway.app")) {
            return url.replace(
              "http://landlens.up.railway.app",
              "https://landlens.up.railway.app",
            );
          }
          if (url.startsWith("http://")) {
            return url.replace("http://", "https://");
          }
          return url;
        } catch (err) {
          return url;
        }
      }

      function resetDesignPreview() {
        if (ui.mobileDesignCurrent) {
          ui.mobileDesignCurrent.textContent = "Choose…";
        }
      }

      function drawDesignFootprint(design, previewData, targetCanvas) {
        const canvas = targetCanvas;
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const points =
          (Array.isArray(design?.footprint_points) &&
            design.footprint_points.length &&
            design.footprint_points) ||
          (Array.isArray(previewData?.footprint_points) &&
            previewData.footprint_points.length &&
            previewData.footprint_points) ||
          null;
        if (!points || points.length < 3) {
          ctx.fillStyle = "#94a3b8";
          ctx.font = "12px system-ui";
          ctx.fillText("No footprint available", 10, canvas.height / 2);
          return;
        }
        const xs = points.map((p) => p[0]);
        const ys = points.map((p) => p[1]);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const pad = 12;
        const usableWidth = canvas.width - pad * 2;
        const usableHeight = canvas.height - pad * 2;
        const spanX = maxX - minX || 1;
        const spanY = maxY - minY || 1;
        const scale = Math.min(usableWidth / spanX, usableHeight / spanY);
        ctx.fillStyle = "#bfdbfe";
        ctx.strokeStyle = "#1d4ed8";
        ctx.lineWidth = 2;
        ctx.beginPath();
        points.forEach((point, index) => {
          const x = pad + (point[0] - minX) * scale;
          const y = canvas.height - pad - (point[1] - minY) * scale;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      async function ensureDesignPreviewData(design) {
        if (!design) return null;
        const cacheKey =
          design.slug || design.id || design.name || design.dxf_url;
        if (appState.designPreviews[cacheKey]) {
          return appState.designPreviews[cacheKey];
        }
        const hasEmbeddedFootprint =
          Array.isArray(design.footprint_points) &&
          design.footprint_points.length > 0 &&
          Array.isArray(design.front_direction) &&
          design.front_direction.length >= 2;
        if (hasEmbeddedFootprint && !appState.designPreviews[cacheKey]) {
          appState.designPreviews[cacheKey] = {
            footprint_points: design.footprint_points,
            front_direction: design.front_direction,
          };
          return appState.designPreviews[cacheKey];
        }
        const filename = getDesignFilename(design);
        if (!filename) return null;
        try {
          const preview = await fetchJSON(
            `/files/${encodeURIComponent(filename)}/preview`,
          );
          if (preview) {
            appState.designPreviews[cacheKey] = preview;
            populateDesktopDesignList();
            populateMobileDesignList();
            return preview;
          }
        } catch (err) {
          logMessage(
            "Design preview fetch failed",
            { error: err.message },
            "error",
          );
        }
        return null;
      }

      function setStatus(message, type = "info") {
        if (!message) {
          statusEl.textContent = "";
          statusEl.classList.add("hidden");
          return;
        }
        statusEl.textContent = message;
        statusEl.classList.remove("hidden");
        statusEl.classList.toggle("error", type === "error");
        console[type === "error" ? "error" : "log"]("[Map status]", message);
      }

      function setDesignStatus(message, type = "info") {
        if (!ui.designStatus) return;
        ui.designStatus.textContent = message || "";
        ui.designStatus.classList.toggle("error", type === "error");
      }

      function updateJobStatus(message, type = "info") {
        if (!ui.jobStatusText) return;
        ui.jobStatusText.textContent = message || "";
        ui.jobStatusText.style.color = type === "error" ? "#d93025" : "#0f172a";
      }

      function updateJobMeta(message) {
        if (!ui.jobMetaText) return;
        ui.jobMetaText.textContent = message || "";
      }

      function setControlsDisabled(disabled) {
        ui.designSelect.disabled = disabled;
        ui.refreshDesignsBtn.disabled = disabled;
        document
          .querySelectorAll(".desktop-design-row, .mobile-design-row")
          .forEach((row) => {
            row.disabled = disabled;
          });
      }

      function updateJobControlButtons() {
        const state = appState.jobControlState || "hidden";
        const config =
          state === "stop"
            ? { label: "Stop job", stop: true, visible: true }
            : state === "clear"
              ? { label: "Clear job", stop: false, visible: true }
              : { label: "Stop job", stop: true, visible: false };
        const buttons = [
          { el: ui.cancelJobBtn, block: false },
          { el: ui.mobileCancelBtn, block: true },
        ];
        buttons.forEach(({ el, block }) => {
          if (!el) return;
          el.textContent = config.label;
          el.classList.remove("btn-stop", "btn-clear");
          if (config.visible) {
            el.style.display = block ? "block" : "inline-block";
            el.classList.add(config.stop ? "btn-stop" : "btn-clear");
            el.disabled = false;
          } else {
            el.style.display = "none";
            el.disabled = true;
          }
        });
      }

      function setJobControlState(state) {
        appState.jobControlState = state;
        updateJobControlButtons();
      }

      function handleJobControlClick(event) {
        event.preventDefault();
        if (appState.jobControlState === "stop") {
          handleStopJob();
        } else if (appState.jobControlState === "clear") {
          clearJobView();
        }
      }

      function generateLogId() {
        if (
          typeof window !== "undefined" &&
          window.crypto &&
          typeof window.crypto.randomUUID === "function"
        ) {
          return window.crypto.randomUUID();
        }
        return `log-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      window.addEventListener("error", (event) => {
        if (!event?.message) return;
        setStatus(`JS error: ${event.message}`, "error");
      });

      window.addEventListener("unhandledrejection", (event) => {
        const reason =
          event?.reason?.message || event?.reason || "Unknown rejection";
        setStatus(`Promise rejection: ${reason}`, "error");
      });

      function formatTileTemplate(template) {
        return template
          .replace("{z}", "0")
          .replace("{x}", "0")
          .replace("{y}", "0");
      }

      async function sampleTileUrl(styleJSON) {
        const sources = styleJSON?.sources || {};
        for (const source of Object.values(sources)) {
          const tileUrl = await firstTileFromSource(source);
          if (tileUrl) return tileUrl;
        }
        return null;
      }

      async function firstTileFromSource(source) {
        if (!source) return null;

        if (Array.isArray(source.tiles) && source.tiles.length > 0) {
          const template = source.tiles[0];
          if (typeof template === "string") {
            return formatTileTemplate(template);
          }
        }

        if (source.url) {
          try {
            const response = await fetch(source.url);
            if (!response.ok) {
              throw new Error(`TileJSON fetch failed (${response.status})`);
            }
            const tileJSON = await response.json();
            if (Array.isArray(tileJSON.tiles) && tileJSON.tiles.length) {
              return formatTileTemplate(tileJSON.tiles[0]);
            }
          } catch (err) {
            console.error("TileJSON fetch failed", err);
          }
        }

        return null;
      }

      async function verifyTileAccess(styleJSON) {
        const tileUrl = await sampleTileUrl(styleJSON);
        if (!tileUrl) {
          setStatus("No tile URL found in style.", "error");
          return false;
        }

        setStatus("Testing tile access...");
        try {
          const response = await fetch(tileUrl, { method: "HEAD" });
          if (!response.ok) {
            throw new Error(`Tile fetch failed (${response.status})`);
          }
          return true;
        } catch (err) {
          setStatus(`Tile test failed: ${err.message}`, "error");
          return false;
        }
      }

      async function initMap() {
        setStatus("Checking MapTiler style...");
        let styleJSON;
        try {
          const response = await fetch(styleUrl);
          if (!response.ok) {
            throw new Error(`Style fetch failed (${response.status})`);
          }
          styleJSON = await response.json();
        } catch (err) {
          setStatus(`Unable to load style: ${err.message}`, "error");
          return;
        }

        const tileAccessOk = await verifyTileAccess(styleJSON);
        if (!tileAccessOk) {
          console.warn("Continuing without tile access.");
        }

        setStatus("Initializing map...");
        const desktopCenter = [-84.44226, 33.74701];
        const mobileCenter = [-84.386, 33.749];
        const initialCenter = document.body.classList.contains("mobile-mode")
          ? mobileCenter
          : desktopCenter;
        map = new maplibregl.Map({
          container: "map",
          style: styleJSON,
          center: initialCenter,
          zoom: 11,
        });

        map.addControl(new maplibregl.NavigationControl(), "top-right");

        let loadTimeout = setTimeout(() => {
          setStatus(
            "Map still loading... check network/API key restrictions.",
            "error",
          );
        }, 7000);

        map.on("load", () => {
          clearTimeout(loadTimeout);
          setStatus("Map style loaded, waiting for tiles...");
          initializeJobLayers();
          initializeOverlaySources();
          attachLongPressHandler();
          map.on("click", handleMapClick);
        });

        map.on("idle", () => {
          setStatus("");
        });

        map.on("error", (event) => {
          const err = event?.error;
          if (!err) return;
          const msg = err.status
            ? `${err.status} ${err.statusText || ""}`.trim()
            : err.message || "Unknown map error";
          setStatus(`Map error: ${msg}`, "error");
        });
      }

      function initializeJobLayers() {
        if (!map || map.getSource(JOB_SOURCE_ID)) return;
        map.addSource(JOB_SOURCE_ID, {
          type: "geojson",
          data: EMPTY_GEOJSON,
        });
        const applyTransitions = () => {
          map.setPaintProperty(JOB_FILL_LAYER_ID, "fill-opacity-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(JOB_FILL_LAYER_ID, "fill-color-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(JOB_LINE_LAYER_ID, "line-opacity-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(JOB_LINE_LAYER_ID, "line-color-transition", {
            duration: 120,
            delay: 0,
          });
        };
        map.addLayer({
          id: JOB_FILL_LAYER_ID,
          type: "fill",
          source: JOB_SOURCE_ID,
          paint: {
            "fill-color": "#4f46e5",
            "fill-opacity": 0.22,
          },
        });
        map.addLayer({
          id: JOB_LINE_LAYER_ID,
          type: "line",
          source: JOB_SOURCE_ID,
          paint: {
            "line-color": "#3730a3",
            "line-width": 2,
          },
        });
        applyTransitions();
      }

      function initializeOverlaySources() {
        if (!map) return;
        if (!map.getSource(PARCEL_BOUNDARY_SOURCE_ID)) {
          map.addSource(PARCEL_BOUNDARY_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PARCEL_FILL_LAYER_ID,
            type: "fill",
            source: PARCEL_BOUNDARY_SOURCE_ID,
            paint: {
              "fill-color": "#ffffff",
              "fill-opacity": 0.65,
            },
          });
          map.addLayer({
            id: PARCEL_BOUNDARY_LAYER_ID,
            type: "line",
            source: PARCEL_BOUNDARY_SOURCE_ID,
            paint: {
              "line-color": "#10b981",
              "line-width": 2,
              "line-dasharray": [2, 2],
            },
          });
          map.addLayer({
            id: PARCEL_BOUNDARY_SELECTED_LAYER_ID,
            type: "line",
            source: PARCEL_BOUNDARY_SOURCE_ID,
            paint: {
              "line-color": "#10b981",
              "line-width": 3,
              "line-dasharray": [1, 0],
            },
            filter: ["==", ["get", "parcelId"], ""],
          });
          map.setPaintProperty(PARCEL_FILL_LAYER_ID, "fill-opacity-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(PARCEL_FILL_LAYER_ID, "fill-color-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(
            PARCEL_BOUNDARY_LAYER_ID,
            "line-opacity-transition",
            { duration: 120, delay: 0 },
          );
          map.setPaintProperty(
            PARCEL_BOUNDARY_LAYER_ID,
            "line-color-transition",
            { duration: 120, delay: 0 },
          );
          map.setPaintProperty(
            PARCEL_BOUNDARY_SELECTED_LAYER_ID,
            "line-opacity-transition",
            { duration: 120, delay: 0 },
          );
          map.setPaintProperty(
            PARCEL_BOUNDARY_SELECTED_LAYER_ID,
            "line-color-transition",
            { duration: 120, delay: 0 },
          );
          if (!appState.parcelLayerHandlersBound) {
            map.on("click", PARCEL_FILL_LAYER_ID, handleParcelFeatureClick);
            map.on("mouseenter", PARCEL_FILL_LAYER_ID, () => {
              map.getCanvas().style.cursor = "pointer";
            });
            map.on("mouseleave", PARCEL_FILL_LAYER_ID, () => {
              map.getCanvas().style.cursor = "";
            });
            appState.parcelLayerHandlersBound = true;
          }
        }
        if (!map.getSource(SHADOW_SOURCE_ID)) {
          map.addSource(SHADOW_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: SHADOW_LAYER_ID,
            type: "fill",
            source: SHADOW_SOURCE_ID,
            paint: {
              "fill-color": "#a21caf",
              "fill-opacity": 0.25,
            },
          });
          map.setPaintProperty(SHADOW_LAYER_ID, "fill-opacity-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(SHADOW_LAYER_ID, "fill-color-transition", {
            duration: 120,
            delay: 0,
          });
        }
        if (!map.getSource(PLACEMENT_SOURCE_ID)) {
          map.addSource(PLACEMENT_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PLACEMENT_LAYER_ID,
            type: "fill",
            source: PLACEMENT_SOURCE_ID,
            paint: {
              "fill-color": [
                "case",
                ["==", ["get", "isBest"], true],
                "#f97316",
                "#2563eb",
              ],
              "fill-opacity": [
                "case",
                ["==", ["get", "isBest"], true],
                0.5,
                0.2,
              ],
              "fill-outline-color": "#1f2937",
            },
          });
          map.setPaintProperty(PLACEMENT_LAYER_ID, "fill-opacity-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(PLACEMENT_LAYER_ID, "fill-color-transition", {
            duration: 120,
            delay: 0,
          });
          map.setPaintProperty(
            PLACEMENT_LAYER_ID,
            "fill-outline-color-transition",
            { duration: 120, delay: 0 },
          );
        }
        if (!map.getSource(PLACEMENT_LABEL_SOURCE_ID)) {
          map.addSource(PLACEMENT_LABEL_SOURCE_ID, {
            type: "geojson",
            data: EMPTY_GEOJSON,
          });
          map.addLayer({
            id: PLACEMENT_LABEL_LAYER_ID,
            type: "symbol",
            source: PLACEMENT_LABEL_SOURCE_ID,
            layout: {
              "text-field": [
                "case",
                ["has", "score"],
                ["concat", "Score ", ["get", "score"]],
                "",
              ],
              "text-size": 12,
              "text-anchor": "center",
            },
            paint: {
              "text-color": "#111827",
              "text-halo-color": "#ffffff",
              "text-halo-width": 1,
            },
          });
          map.setPaintProperty(
            PLACEMENT_LABEL_LAYER_ID,
            "text-opacity-transition",
            { duration: 120, delay: 0 },
          );
          map.setPaintProperty(
            PLACEMENT_LABEL_LAYER_ID,
            "text-color-transition",
            { duration: 120, delay: 0 },
          );
        }
      }

      function updateJobSource(data) {
        if (!map) return;
        const source = map.getSource(JOB_SOURCE_ID);
        if (source) {
          source.setData(data || EMPTY_GEOJSON);
        }
      }

      function logMessage(message, payload, level = "info") {
        const timestamp = new Date().toLocaleTimeString();
        const consolePayload =
          payload != null && typeof payload !== "undefined" ? payload : "";
        console[level === "error" ? "error" : "log"](
          `[${timestamp}] ${message}`,
          consolePayload,
        );
      }

      function renderStatusFeed() {
        if (!ui.statusFeed) return;
        if (!appState.eventFeed.length) {
          ui.statusFeed.innerHTML = `<div class="status-item muted"><div class="status-dot"></div><div><div class="status-message">${appState.statusFeedMessage || "No activity yet."}</div></div></div>`;
          return;
        }
        const items = appState.eventFeed
          .slice()
          .reverse()
          .map(
            (entry) => `
          <div class="status-item ${entry.tone || "info"}">
            <div class="status-dot"></div>
            <div>
              <div class="status-message">${entry.message}</div>
              <div class="status-time">${entry.time}</div>
            </div>
          </div>
        `,
          )
          .join("");
        ui.statusFeed.innerHTML = items;
      }

      function pushStatusUpdate(message, tone = "info") {
        appState.eventFeed.push({
          message,
          tone,
          time: new Date().toLocaleTimeString(),
        });
        if (appState.eventFeed.length > STATUS_FEED_LIMIT) {
          appState.eventFeed.shift();
        }
        renderStatusFeed();
      }

      function resetEventFeed(message) {
        appState.eventFeed = [];
        appState.statusFeedMessage = message || "No activity yet.";
        renderStatusFeed();
      }

      function recordCrawlerEventSummary(event, payload) {
        const typeRaw = event?.type || event?.event || "event";
        const eventType = String(typeRaw).toLowerCase();
        if (eventType === "placement_scored") {
          return;
        }
        const timestampSource = event?.timestamp || event?.time;
        let timestamp = new Date().toLocaleTimeString();
        if (timestampSource) {
          const date = new Date(timestampSource);
          if (!Number.isNaN(date.getTime())) {
            timestamp = date.toLocaleTimeString();
          }
        }
        const parcelId =
          event?.parcel_id ||
          payload?.parcel_id ||
          payload?.parcelId ||
          "parcel";
        let message;
        const score =
          payload?.score != null
            ? Number(payload.score).toFixed(1)
            : payload?.max_composite != null
              ? Number(payload.max_composite).toFixed(1)
              : null;
        switch (eventType) {
          case "parcel_started":
            message = `Parcel ${parcelId} started (${payload?.zoning || "zoning n/a"})`;
            break;
          case "best_updated":
            message = `Parcel ${parcelId} best updated${
              score ? ` (score ${score})` : ""
            }.`;
            break;
          case "parcel_completed":
            message = `Parcel ${parcelId} completed.`;
            break;
          case "parcel_failed":
            message = `Parcel ${parcelId} failed.`;
            break;
          case "parcel_progress":
            message = `Parcel ${parcelId} progress: ${
              payload?.placements != null ? `${payload.placements} placements` : "updated"
            }.`;
            break;
          default:
            message = `Event ${eventType.replace(/_/g, " ")} for parcel ${parcelId}.`;
            break;
        }
        let tone = "info";
        if (eventType === "parcel_failed") {
          tone = "error";
        } else if (
          eventType === "parcel_completed" ||
          eventType === "best_updated"
        ) {
          tone = "success";
        }
        pushStatusUpdate(message, tone);
      }

      async function fetchJSON(path, options = {}) {
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const headers = options.headers ? { ...options.headers } : {};
        if (
          options.body &&
          !(options.body instanceof FormData) &&
          !headers["Content-Type"]
        ) {
          headers["Content-Type"] = "application/json";
        }
        const fetchOptions = { ...options, headers, signal };
        if (!options.signal) {
          appState.abortControllers.add(controller);
        }
        try {
          const response = await fetch(`${API_BASE}${path}`, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          if (response.status === 204) return null;
          return response.json();
        } finally {
          if (!options.signal) {
            appState.abortControllers.delete(controller);
          }
        }
      }

      async function fetchExternalJSON(url, options = {}) {
        if (!url) return null;
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const headers = options.headers ? { ...options.headers } : {};
        const fetchOptions = { ...options, headers, signal };
        appState.abortControllers.add(controller);
        try {
          const response = await fetch(url, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          return response.json();
        } finally {
          appState.abortControllers.delete(controller);
        }
      }

      async function fetchText(path, options = {}) {
        const controller = new AbortController();
        const signal = options.signal || controller.signal;
        const fetchOptions = { ...options, signal };
        if (!options.signal) {
          appState.abortControllers.add(controller);
        }
        try {
          const response = await fetch(`${API_BASE}${path}`, fetchOptions);
          if (!response.ok) {
            const body = await response.text();
            throw new Error(
              body ||
                response.statusText ||
                `Request failed (${response.status})`,
            );
          }
          return response.text();
        } finally {
          if (!options.signal) {
            appState.abortControllers.delete(controller);
          }
        }
      }

      function getDesignOptionValue(design, index) {
        if (!design) return `design-${index}`;
        return (
          design.slug ||
          design.id ||
          design.name ||
          design.dxf_url ||
          `design-${index}`
        );
      }

      async function loadDesigns() {
        setDesignStatus("Loading designs...");
        logMessage("GET /designs");
        try {
          const payload = await fetchJSON("/designs");
          const designs = Array.isArray(payload)
            ? payload
            : payload?.designs || [];
          let previousSelectionValue = null;
          if (
            typeof appState.selectedDesignIndex === "number" &&
            appState.designs[appState.selectedDesignIndex]
          ) {
            previousSelectionValue = getDesignOptionValue(
              appState.designs[appState.selectedDesignIndex],
              appState.selectedDesignIndex,
            );
          } else if (appState.selectedDesign) {
            previousSelectionValue = getDesignOptionValue(
              appState.selectedDesign,
              appState.selectedDesignIndex ?? -1,
            );
          }
          appState.designs = designs;
          populateDesignSelect(previousSelectionValue);
          setDesignStatus(
            `Loaded ${designs.length} design${designs.length === 1 ? "" : "s"}.`,
          );
          logMessage("Designs loaded", { count: designs.length });
          if (!designs.length) {
            resetDesignPreview();
          }
        } catch (err) {
          console.error(err);
          setDesignStatus(`Failed to load designs: ${err.message}`, "error");
          logMessage("Design load failed", { error: err.message }, "error");
          resetDesignPreview();
        }
      }

      function populateDesignSelect(previousSelectionValue) {
        const select = ui.designSelect;
        if (!select) return;
        select.innerHTML =
          '<option value="">-- Select a design --</option>';
        const shouldRestore =
          typeof previousSelectionValue === "string" &&
          previousSelectionValue.length > 0;
        let restoredValue = null;
        appState.designs.forEach((design, index) => {
          const option = document.createElement("option");
          const optionValue = getDesignOptionValue(design, index);
          option.value = optionValue;
          option.textContent =
            design.name || design.slug || `Design ${index + 1}`;
          option.dataset.index = index;
          if (!restoredValue && shouldRestore && optionValue === previousSelectionValue) {
            restoredValue = optionValue;
            appState.selectedDesignIndex = index;
          }
          select.appendChild(option);
        });
        if (restoredValue) {
          select.value = restoredValue;
        } else {
          select.value = "";
          select.selectedIndex = 0;
          appState.selectedDesign = null;
          appState.selectedDesignIndex = null;
        }
        populateDesktopDesignList();
        populateMobileDesignList();
        if (restoredValue) {
          handleDesignChange();
        } else {
          updateDesignRowStates();
          updateJobStatus(
            "Select a design and long press on the map to start a crawl.",
          );
          updateJobMeta("");
          resetDesignPreview();
        }
      }

      function populateMobileDesignList() {
        if (!ui.mobileDesignList) return;
        ui.mobileDesignList.innerHTML = "";
        appState.designs.forEach((design, index) => {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "mobile-design-row";
          row.dataset.index = String(index);
          const canvas = document.createElement("canvas");
          canvas.width = 120;
          canvas.height = 90;
          canvas.className = "design-thumb";
          row.appendChild(canvas);
          const info = document.createElement("div");
          info.className = "mobile-design-info";
          const title = document.createElement("strong");
          title.textContent = design.name || design.slug || `Design ${index + 1}`;
          const meta = document.createElement("span");
          meta.textContent = `${design?.footprint_points?.length || 0} points`;
          info.appendChild(title);
          info.appendChild(meta);
          row.appendChild(info);
          row.addEventListener("click", () => {
            selectDesignByIndex(index);
            closeMobileDesignMenu();
          });
          ui.mobileDesignList.appendChild(row);
          const cacheKey =
            design.slug || design.id || design.name || design.dxf_url;
          drawDesignFootprint(
            design,
            appState.designPreviews[cacheKey],
            canvas,
          );
          if (
            !appState.designPreviews[cacheKey] &&
            (!Array.isArray(design.footprint_points) ||
              !design.footprint_points.length)
          ) {
            ensureDesignPreviewData(design);
          }
        });
        updateDesignRowStates();
      }

      function populateDesktopDesignList() {
        if (!ui.desktopDesignList) return;
        ui.desktopDesignList.innerHTML = "";
        appState.designs.forEach((design, index) => {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "desktop-design-row";
          row.dataset.index = String(index);
          const canvas = document.createElement("canvas");
          canvas.width = 140;
          canvas.height = 90;
          canvas.className = "design-thumb";
          row.appendChild(canvas);
          const info = document.createElement("div");
          info.className = "mobile-design-info";
          const title = document.createElement("strong");
          title.textContent = design.name || design.slug || `Design ${index + 1}`;
          const meta = document.createElement("span");
          meta.textContent = `${design?.footprint_points?.length || 0} points`;
          info.appendChild(title);
          info.appendChild(meta);
          row.appendChild(info);
          row.addEventListener("click", () => selectDesignByIndex(index));
          ui.desktopDesignList.appendChild(row);
          const cacheKey =
            design.slug || design.id || design.name || design.dxf_url;
          drawDesignFootprint(
            design,
            appState.designPreviews[cacheKey],
            canvas,
          );
          if (
            !appState.designPreviews[cacheKey] &&
            (!Array.isArray(design.footprint_points) ||
              !design.footprint_points.length)
          ) {
            ensureDesignPreviewData(design);
          }
        });
        updateDesignRowStates();
      }

      function selectDesignByIndex(index) {
        const select = ui.designSelect;
        if (!select) return;
        const option = Array.from(select.options).find(
          (opt) => opt.dataset.index === String(index),
        );
        if (option) {
          select.value = option.value;
          appState.selectedDesignIndex = index;
          handleDesignChange();
        }
      }

      function updateDesignRowStates() {
        const activeIndex =
          typeof appState.selectedDesignIndex === "number"
            ? appState.selectedDesignIndex
            : -1;
        document
          .querySelectorAll(".mobile-design-row, .desktop-design-row")
          .forEach((row) => {
            const idx = Number(row.dataset.index);
            if (idx === activeIndex) {
              row.classList.add("active");
            } else {
              row.classList.remove("active");
            }
          });
      }

      function handleDesignChange() {
        const select = ui.designSelect;
        if (!select) return;
        const option = select.selectedOptions[0];
        if (!option || !option.dataset.index) {
          appState.selectedDesign = null;
          appState.selectedDesignIndex = null;
          updateDesignRowStates();
          updateJobStatus("Select a design and long press on the map to start a crawl.");
          updateJobMeta("");
          resetDesignPreview();
          return;
        }
        const design = appState.designs[Number(option.dataset.index)];
        appState.selectedDesign = design;
        appState.selectedDesignIndex = Number(option.dataset.index);
        if (ui.mobileDesignCurrent) {
          ui.mobileDesignCurrent.textContent = design.name || design.slug || "Design";
        }
        updateDesignRowStates();
        updateJobStatus("Design selected. Long press on the map to start a crawl.");
        updateJobMeta("");
        ensureDesignPreviewData(design);
      }

      function toggleMobileDesignMenu() {
        if (!ui.mobileDesignMenu) return;
        appState.mobileDesignMenuOpen = !appState.mobileDesignMenuOpen;
        ui.mobileDesignMenu.classList.toggle(
          "hidden",
          !appState.mobileDesignMenuOpen,
        );
      }

      function closeMobileDesignMenu() {
        if (!ui.mobileDesignMenu) return;
        appState.mobileDesignMenuOpen = false;
        ui.mobileDesignMenu.classList.add("hidden");
      }

      async function handleMapClick(event) {
        if (suppressNextClick) {
          suppressNextClick = false;
          return;
        }
        if (appState.parcelPopup) {
          clearParcelTooltip();
          appState.selectedParcelId = null;
          updateSelectedParcelHighlight();
          resetParcelInfoPanel();
          return;
        }
        await showAddressPopup(event.lngLat);
      }

      function normalizeParcelId(raw) {
        if (!raw && raw !== 0) return null;
        return String(raw).replace(/_/g, " ").replace(/\s+/g, " ").trim();
      }

      function getParcelDetail(parcelId) {
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return null;
        return appState.overlayStore.parcelDetails.get(normalized) || null;
      }

      function ensureParcelDetail(parcelId) {
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return null;
        const store = appState.overlayStore.parcelDetails;
        if (!store.has(normalized)) {
          store.set(normalized, {
            parcelId: normalized,
            parcel: null,
            summary: null,
            bestPlacement: null,
            latestPlacement: null,
            lastUpdated: Date.now(),
          });
        }
        const detail = store.get(normalized);
        if (detail) detail.parcelId = normalized;
        return detail;
      }

      function resetParcelInfoPanel(message) {}

      function formatOwner(parcel) {
        const owners = [parcel?.OWNERNME1, parcel?.OWNERNME2].filter(Boolean);
        return owners.length ? owners.join(" / ") : null;
      }

      function formatOverlays(parcel) {
        if (Array.isArray(parcel?.overlay_names) && parcel.overlay_names.length) {
          return parcel.overlay_names.join(", ");
        }
        if (Array.isArray(parcel?.overlays) && parcel.overlays.length) {
          return parcel.overlays.join(", ");
        }
        return null;
      }

      function updateParcelInfoPanel() {}

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function formatListValue(value) {
        if (!value) return null;
        if (Array.isArray(value)) {
          const flat = value.flat(Infinity).filter(Boolean);
          return flat.length ? flat.join(", ") : null;
        }
        if (typeof value === "object") {
          const vals = Object.values(value || {}).filter(Boolean);
          return vals.length ? vals.join(", ") : null;
        }
        const str = String(value).trim();
        return str || null;
      }

      function formatParcelDetailHtml(detail) {
        if (!detail) return "<div class=\"parcel-popup\">No details available.</div>";
        const parcel = detail.parcel || {};
        const summary = detail.summary || {};
        const best = detail.bestPlacement;
        const address =
          parcel.SITEADDRESS ||
          parcel.official_address ||
          summary.address ||
          parcel.county_address ||
          detail.parcelId ||
          "";
        const zoning =
          parcel.official_zoning || parcel.zoning_classification || "Unknown zoning";
        const owner = [parcel.OWNERNME1, parcel.OWNERNME2].filter(Boolean).join(" / ");
        const overlays = formatOverlays(parcel);
        const lines = [];
        lines.push("<div class=\"parcel-popup\">");
        lines.push(`<h3>${escapeHtml(address)}</h3>`);
        const rows = [];
        if (summary.max_composite != null) {
          rows.push({
            label: "Score",
            value: `${Number(summary.max_composite).toFixed(1)}`,
          });
        }
        rows.push({ label: "Zoning", value: zoning });
        if (owner) rows.push({ label: "Owner", value: owner });
        if (overlays) rows.push({ label: "Overlays", value: overlays });
        if (parcel.future_land_use) {
          rows.push({ label: "Future land use", value: parcel.future_land_use });
        }
        if (parcel.land_lot_page || parcel.land_lot_link) {
          rows.push({
            label: "Land lot",
            value: parcel.land_lot_page || parcel.land_lot_link,
          });
        }
        if (best && best.rotation_deg != null) {
          const offsetX =
            best.offset_x_m ??
            (Array.isArray(best.offset) ? best.offset[0] : null);
          const offsetY =
            best.offset_y_m ??
            (Array.isArray(best.offset) ? best.offset[1] : null);
          const offsetLine =
            offsetX != null && offsetY != null
              ? ` · Offset (${offsetX}, ${offsetY})`
              : "";
          rows.push({
            label: "Top placement",
            value: `${best.rotation_deg}°${offsetLine}`,
          });
        }
        rows.forEach(({ label, value }) => {
          const formatted = formatListValue(value);
          if (!formatted) return;
          lines.push(
            `<div class="parcel-popup-meta"><strong>${escapeHtml(
              label,
            )}:</strong> ${escapeHtml(formatted)}</div>`,
          );
        });
        const namedLinks = [];
        const fallbackLinks = [];
        const seenLinks = new Set();
        function addNamedLink(url, label) {
          if (!url || seenLinks.has(url)) return;
          namedLinks.push({ label, url });
          seenLinks.add(url);
        }
        function addFallbackLink(url) {
          if (!url || seenLinks.has(url)) return;
          fallbackLinks.push(url);
          seenLinks.add(url);
        }
        const urlRegex = /^https?:\/\//i;
        addNamedLink(parcel.tax_assessor_link, "Tax assessor");
        addNamedLink(parcel.document?.DOC_LINK, "Document");
        addNamedLink(parcel.land_lot_link, "Land lot map");
        addNamedLink(parcel.zoning_link, "Zoning details");
        ["links", "urls"].forEach((key) => {
          if (Array.isArray(parcel[key])) {
            parcel[key].forEach((url) => {
              if (urlRegex.test(url)) addFallbackLink(url);
            });
          }
        });
        function collectUnknownLinks(value) {
          if (!value) return;
          if (typeof value === "string") {
            if (urlRegex.test(value)) addFallbackLink(value);
            return;
          }
          if (Array.isArray(value)) {
            value.forEach(collectUnknownLinks);
            return;
          }
          if (typeof value === "object") {
            Object.values(value).forEach(collectUnknownLinks);
          }
        }
        collectUnknownLinks(parcel.extra_links);
        const linkEntries = [...namedLinks];
        fallbackLinks.forEach((url, idx) => {
          linkEntries.push({ label: `Link ${idx + 1}`, url });
        });
        if (linkEntries.length) {
          const linkHtml = linkEntries
            .map(
              (entry) =>
                `<a href="${escapeHtml(entry.url)}" target="_blank" rel="noopener">${escapeHtml(entry.label)}</a>`,
            )
            .join(" · ");
          lines.push(
            `<div class="parcel-popup-meta"><strong>Links:</strong> ${linkHtml}</div>`,
          );
        }
        lines.push("</div>");
        return lines.join("");
      }

      function getParcelFeatureById(parcelId) {
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return null;
        const store = appState.overlayStore;
        if (store.parcels.has(normalized)) {
          return store.parcels.get(normalized);
        }
        for (const feature of store.parcels.values()) {
          const id =
            feature.properties?.parcelId || feature.properties?.id || null;
          if (normalizeParcelId(id) === normalized) {
            return feature;
          }
        }
        return null;
      }

      function clearParcelTooltip() {
        if (appState.parcelPopup) {
          appState.parcelPopup.remove();
          appState.parcelPopup = null;
          appState.activeParcelPopupId = null;
        }
      }

      function showParcelTooltip(parcelId, detail) {
        if (!map || !detail) return;
        const feature = getParcelFeatureById(parcelId);
        let lngLat = null;
        if (feature?.geometry?.coordinates) {
          const centroid = computeCentroid(feature.geometry.coordinates);
          if (centroid && Number.isFinite(centroid[0]) && Number.isFinite(centroid[1])) {
            lngLat = [centroid[0], centroid[1]];
          }
        }
        if (!lngLat) {
          const center = map.getCenter();
          lngLat = [center.lng, center.lat];
        }
        const html = formatParcelDetailHtml(detail);
        clearParcelTooltip();
        const popup = new maplibregl.Popup({ maxWidth: "320px" })
          .setLngLat(lngLat)
          .setHTML(html)
          .addTo(map);
        popup.on("close", () => {
          if (appState.parcelPopup === popup) {
            appState.parcelPopup = null;
            appState.activeParcelPopupId = null;
          }
        });
        appState.parcelPopup = popup;
        appState.activeParcelPopupId = parcelId;
      }

      function updateLeaderboard() {
        const detailMap = appState.overlayStore.parcelDetails;
        const entries = Array.from(detailMap.entries())
          .map(([parcelId, detail]) => ({
            parcelId,
            detail,
            score: Number(detail.summary?.max_composite) || 0,
          }))
          .filter((entry) => entry.score > 0)
          .sort((a, b) => b.score - a.score)
          .slice(0, 10);
        appState.leaderboardEntries = entries;
        renderLeaderboard();
      }

      function renderLeaderboard() {
        const lists = [ui.leaderboardList, ui.desktopFlyoutList].filter(Boolean);
        const detailTargets = [
          ui.leaderboardDetail,
          ui.desktopFlyoutDetail,
        ].filter(Boolean);
        const shouldShow =
          appState.leaderboardEntries.length > 0 || Boolean(appState.job);
        lists.forEach((list) => (list.innerHTML = ""));
        if (!appState.leaderboardEntries.length) {
          detailTargets.forEach((target) => {
            if (target) {
              target.textContent = "Placements will appear here during a crawl.";
            }
          });
          setDesktopLeaderboardVisibility(shouldShow);
          return;
        }
        appState.leaderboardEntries.forEach((entry) => {
          const rowTemplate = document.createElement("button");
          rowTemplate.type = "button";
          rowTemplate.className = "leaderboard-row";
          if (appState.leaderboardSelectedId === entry.parcelId) {
            rowTemplate.classList.add("active");
          }
          const title = document.createElement("div");
          title.textContent =
            entry.detail.summary?.address || entry.parcelId || "Parcel";
          const score = document.createElement("div");
          score.className = "leaderboard-row-score";
          score.textContent = entry.score.toFixed(1);
          rowTemplate.appendChild(title);
          rowTemplate.appendChild(score);
          lists.forEach((list) => {
            if (!list) return;
            const row = rowTemplate.cloneNode(true);
            row.addEventListener("click", () => {
              appState.leaderboardSelectedId = entry.parcelId;
              renderLeaderboard();
              showLeaderboardDetail(entry);
              appState.selectedParcelId = entry.parcelId;
              updateSelectedParcelHighlight();
              ensureParcelDetailLoaded(entry.parcelId).then(() => {
                const detail = getParcelDetail(entry.parcelId);
                showParcelTooltip(entry.parcelId, detail);
              });
            });
            list.appendChild(row);
          });
        });
        if (appState.leaderboardSelectedId) {
          const selected = appState.leaderboardEntries.find(
            (entry) => entry.parcelId === appState.leaderboardSelectedId,
          );
          if (selected) {
            showLeaderboardDetail(selected);
          }
        }
        setDesktopLeaderboardVisibility(shouldShow);
      }

      function showLeaderboardDetail(entry) {
        const targets = [
          ui.leaderboardDetail,
          ui.desktopFlyoutDetail,
        ].filter(Boolean);
        targets.forEach((target) => {
          target.innerHTML = formatParcelDetailHtml(entry.detail);
        });
      }

      function setLeaderboardTray(open) {
        if (!ui.leaderboardTray || !ui.leaderboardToggle) return;
        appState.leaderboardOpen = open;
        ui.leaderboardTray.classList.toggle("collapsed", !open);
        ui.leaderboardToggle.textContent = open ? "Hide" : "View";
      }

      function toggleLeaderboardTray() {
        setLeaderboardTray(!appState.leaderboardOpen);
      }

      function setDesktopLeaderboardVisibility(active) {
        if (!ui.desktopLeaderboardFlyout) return;
        ui.desktopLeaderboardFlyout.classList.toggle("visible", Boolean(active));
      }

      function ingestParcelDataset(dataset) {
        if (!dataset) return;
        const parcelIdCandidate =
          dataset.summary?.parcel_id ||
          dataset.parcel?.LOWPARCELID ||
          dataset.parcel?.parcel_id;
        const normalized = normalizeParcelId(parcelIdCandidate);
        if (!normalized) return;
        const detail = ensureParcelDetail(normalized);
        if (!detail) return;
        if (dataset.parcel) {
          detail.parcel = { ...(detail.parcel || {}), ...dataset.parcel };
        }
        if (dataset.summary) {
          detail.summary = { ...(detail.summary || {}), ...dataset.summary };
        }
        if (dataset.best) {
          detail.bestPlacement = dataset.best;
        }
        detail.lastUpdated = Date.now();
        if (appState.selectedParcelId === normalized) {
          updateParcelInfoPanel(normalized);
        }
        updateLeaderboard();
      }

      function ingestParcelSummaryFromOverlayFeature(feature) {
        if (!feature?.properties) return;
        const parcelId =
          feature.properties.parcelId || feature.properties.parcel_id;
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return;
        const detail = ensureParcelDetail(normalized);
        if (!detail) return;
        const summaryPatch = {
          parcel_id: normalized,
        };
        if (feature.properties.address) {
          summaryPatch.address = feature.properties.address;
        }
        if (feature.properties.viable_count != null) {
          summaryPatch.viable_count = feature.properties.viable_count;
        }
        if (feature.properties.max_composite != null) {
          summaryPatch.max_composite = feature.properties.max_composite;
        }
        detail.summary = { ...(detail.summary || {}), ...summaryPatch };
        detail.lastUpdated = Date.now();
        if (appState.selectedParcelId === normalized) {
          updateParcelInfoPanel(normalized);
        }
        updateLeaderboard();
      }

      function updateParcelPlacementDetail(parcelId, placement, isBest) {
        const normalized = normalizeParcelId(parcelId);
        if (!normalized || !placement) return;
        const detail = ensureParcelDetail(normalized);
        if (!detail) return;
        const composite = getPlacementCompositeScore(placement);
        const placementInfo = {
          index:
            placement.index ??
            placement.sequence ??
            placement.position ??
            null,
          score: composite,
          rotation_deg: placement.rotation_deg,
          offset_x_m: placement.offset_x_m,
          offset_y_m: placement.offset_y_m,
          offset: placement.offset,
        };
        detail.latestPlacement = placementInfo;
        if (isBest) {
          detail.bestPlacement = placementInfo;
          detail.summary = detail.summary || { parcel_id: normalized };
          if (composite != null) {
            detail.summary.max_composite = composite;
          }
        }
        detail.lastUpdated = Date.now();
        if (appState.selectedParcelId === normalized) {
          updateParcelInfoPanel(normalized);
        }
      }

      async function ensureParcelDetailLoaded(parcelId) {
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return null;
        const existing = getParcelDetail(normalized);
        if (existing?.parcel) {
          existing.parcelId = normalized;
          return existing;
        }
        const url = appState.parcelArtifactIndex[normalized];
        if (!url) return existing;
        try {
          const data = await fetchExternalJSON(url, { cache: "no-store" });
          if (data) {
            ingestParcelDataset(data);
          }
        } catch (err) {
          logMessage(
            "Parcel artifact fetch failed",
            { parcelId: normalized, error: err.message },
            "error",
          );
        }
        const refreshed = getParcelDetail(normalized);
        if (refreshed) {
          refreshed.parcelId = normalized;
        }
        return refreshed;
      }

      async function handleParcelFeatureClick(event) {
        if (suppressNextClick) {
          suppressNextClick = false;
          return;
        }
        const feature = event?.features && event.features[0];
        if (!feature?.properties) return;
        suppressNextClick = true;
        setTimeout(() => {
          suppressNextClick = false;
        }, 0);
        const parcelId =
          feature.properties.parcelId ||
          feature.properties.parcel_id ||
          feature.properties.LOWPARCELID;
        const normalized = normalizeParcelId(parcelId);
        if (!normalized) return;
        if (
          appState.selectedParcelId === normalized &&
          appState.parcelPopup &&
          appState.activeParcelPopupId === normalized
        ) {
          clearParcelTooltip();
          appState.selectedParcelId = null;
          updateSelectedParcelHighlight();
          return;
        }
        appState.selectedParcelId = normalized;
        updateParcelInfoPanel(normalized);
        updateSelectedParcelHighlight();
        const detail = await ensureParcelDetailLoaded(normalized);
        updateParcelInfoPanel(normalized);
        showParcelTooltip(normalized, detail || getParcelDetail(normalized));
      }

      function updateSelectedParcelHighlight() {
        if (!map || !map.getLayer(PARCEL_BOUNDARY_SELECTED_LAYER_ID)) return;
        if (appState.selectedParcelId) {
          map.setFilter(PARCEL_BOUNDARY_SELECTED_LAYER_ID, [
            "==",
            ["get", "parcelId"],
            appState.selectedParcelId,
          ]);
        } else {
          map.setFilter(PARCEL_BOUNDARY_SELECTED_LAYER_ID, [
            "==",
            ["get", "parcelId"],
            "",
          ]);
        }
      }

      function canStartJob() {
        if (!appState.selectedDesign) {
          updateJobStatus(
            "Pick a design before launching a crawl.",
            "error",
          );
          return false;
        }
        if (appState.job) {
          updateJobStatus(
            "A job is already running. Wait or cancel it first.",
            "error",
          );
          return false;
        }
        return true;
      }

      async function showAddressPopup(lngLat) {
        if (addressPopup) {
          addressPopup.remove();
          addressPopup = null;
          return;
        }
        try {
          const address = await reverseGeocode(lngLat);
          addressPopup = showPopup(lngLat, address);
        } catch (err) {
          setStatus(`Reverse geocode failed: ${err.message}`, "error");
          addressPopup = showPopup(lngLat, "Unable to retrieve address");
          console.error(err);
        }
      }

      async function startJobAtPoint(lngLat) {
        const design = appState.selectedDesign;
        if (!design) return;
        setControlsDisabled(true);
        setJobControlState("hidden");
        updateJobSource(EMPTY_GEOJSON);
        clearOverlayData();
        resetEventFeed("Awaiting crawler activity...");
        updateJobMeta("");
        updateJobStatus("Preparing job...");
        let address;
        try {
          address = await reverseGeocode(lngLat);
        } catch (err) {
          console.warn(
            "Reverse geocode failed, falling back to raw coordinates.",
            err,
          );
          address = `Lat ${lngLat.lat.toFixed(5)}, Lng ${lngLat.lng.toFixed(5)}`;
        }
        const config = {
          target_lat: lngLat.lat,
          target_lon: lngLat.lng,
          cycles: 6,
          parcel_workers: 3,
          score_workers: 6,
          rotation_step: 90,
          buffer: 100,
          setback: 10,
          auto_front: true,
          front_angle: null,
          auto_offset: true,
          auto_offset_scale: 10.0,
          offset_step_scale: 0.75,
          min_composite: 0.0,
          render_cycle: false,
          render_best: false,
          render_composite: false,
          skip_roads: true,
        };
        if (!config.auto_offset) {
          config.offset_step = 0.5;
          config.offset_range = 0.5;
        }
        const payload = {
          address,
          dxf_url: design.dxf_url,
          config,
        };
        if (Array.isArray(design.footprint_points)) {
          payload.footprint_points = design.footprint_points;
        }
        if (Array.isArray(design.front_direction)) {
          payload.front_direction = design.front_direction;
        }
        logMessage("POST /jobs payload", {
          design: design.name,
          lat: lngLat.lat,
          lon: lngLat.lng,
          config: payload.config,
        });
        try {
          const data = await fetchJSON("/jobs", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          appState.job = {
            id: data?.id,
            status: data?.status || "submitted",
            startedAt: Date.now(),
            lngLat,
            designName: design.name || design.slug || "Design",
          };
          setJobControlState("stop");
          logMessage("Job submitted", data);
          placeJobMarker(lngLat);
          updateJobStatus(`Job ${appState.job.id || ""} queued...`);
          updateJobMeta("Waiting for first parcels...");
          scheduleJobPolling();
          startEventStream(appState.job.id);
          requestOverlayRefresh(2500);
          setDesktopLeaderboardVisibility(true);
          pushStatusUpdate(
            `Job ${appState.job.id || ""} queued. Waiting for worker...`,
            "info",
          );
        } catch (err) {
          console.error(err);
          updateJobStatus(`Failed to start job: ${err.message}`, "error");
          logMessage("Job start failed", { error: err.message }, "error");
          pushStatusUpdate("Job failed to start.", "error");
          setControlsDisabled(false);
          setJobControlState("hidden");
        }
      }

      function placeJobMarker(lngLat) {
        if (appState.jobMarker) {
          appState.jobMarker.remove();
          appState.jobMarker = null;
        }
        if (!map) return;
        appState.jobMarker = new maplibregl.Marker({ color: "#be185d" })
          .setLngLat(lngLat)
          .setPopup(
            new maplibregl.Popup().setHTML("<strong>Job origin</strong>"),
          )
          .addTo(map);
      }

      function clearJobMarker() {
        if (appState.jobMarker) {
          appState.jobMarker.remove();
          appState.jobMarker = null;
        }
      }

      function scheduleJobPolling() {
        clearJobPolling();
        fetchJobStatus();
        fetchJobGeo();
        fetchJobArtifacts();
        appState.pollTimers.status = setInterval(
          fetchJobStatus,
          JOB_STATUS_POLL_MS,
        );
        appState.pollTimers.geo = setInterval(fetchJobGeo, JOB_GEO_POLL_MS);
      }

      function clearJobPolling() {
        if (appState.pollTimers.status) {
          clearInterval(appState.pollTimers.status);
          appState.pollTimers.status = null;
        }
        if (appState.pollTimers.geo) {
          clearInterval(appState.pollTimers.geo);
          appState.pollTimers.geo = null;
        }
      }

      function stopEventStream() {
        const state = appState.eventStreamState;
        if (state?.timer) {
          clearInterval(state.timer);
        }
        appState.eventStreamState = {
          jobId: null,
          timer: null,
          cursor: 0,
          pending: false,
        };
      }

      function startEventStream(jobId) {
        stopEventStream();
        if (!jobId) return;
        const state = {
          jobId,
          timer: null,
          cursor: 0,
          pending: false,
        };
        appState.eventStreamState = state;
        pollCrawlerEvents(jobId);
        state.timer = setInterval(
          () => pollCrawlerEvents(jobId),
          EVENT_POLL_INTERVAL_MS,
        );
      }

      async function pollCrawlerEvents(jobId) {
        const state = appState.eventStreamState;
        if (!state || state.jobId !== jobId || state.pending) return;
        state.pending = true;
        try {
          const params = new URLSearchParams({
            cursor: String(state.cursor || 0),
            max_bytes: String(EVENT_POLL_MAX_BYTES),
          });
          const payload = await fetchJSON(
            `/jobs/${encodeURIComponent(jobId)}/events?${params.toString()}`,
          );
          if (typeof payload?.cursor === "number") {
            state.cursor = payload.cursor;
          }
          if (Array.isArray(payload?.events)) {
            payload.events.forEach((event) => handleCrawlerEvent(event));
          }
          if (payload?.has_more) {
            state.pending = false;
            await pollCrawlerEvents(jobId);
            return;
          }
        } catch (err) {
          const message = err?.message || "";
          if (
            message.includes("Events not available yet") ||
            message.includes("not found")
          ) {
            // waiting for worker to create the log file; ignore quietly
          } else {
            logMessage("Event poll error", { error: message }, "error");
          }
        } finally {
          const latestState = appState.eventStreamState;
          if (latestState && latestState.jobId === jobId) {
            latestState.pending = false;
          }
        }
      }

      function handleCrawlerEvent(line) {
        if (!line) return;
        try {
          const raw =
            typeof line === "string"
              ? JSON.parse(line.trim())
              : typeof line === "object"
                ? line
                : null;
          if (!raw) return;
          const eventType = raw.type || raw.event || raw.kind;
          const payload = raw.payload || raw.data || raw;
          const event = {
            ...raw,
            ...payload,
            type: eventType || raw.type,
            parcel_id: raw.parcel_id ?? payload.parcel_id,
            placement: payload.placement || raw.placement,
            parcel: payload.parcel || raw.parcel,
          };
          logMessage("Crawler event", event);
          if (event.message) {
            updateLogTail(event.message);
          } else if (eventType) {
            updateLogTail(eventType);
          }
          switch (eventType) {
            case "parcel_started":
              handleParcelStartedEvent(event);
              break;
            case "placement_scored":
              handlePlacementScoredEvent(event);
              break;
            case "best_updated":
              handleBestUpdatedEvent(event);
              break;
            case "parcel_completed":
            case "parcel_failed":
              recordCrawlerEventSummary(event);
              requestOverlayRefresh(1000);
              break;
            default:
              break;
          }
        } catch (err) {
          logMessage(
            "Event parse error",
            { line: trimmed, error: err.message },
            "error",
          );
        }
      }

      function handleParcelStartedEvent(event) {
        const parcelData = event.parcel || {
          LOWPARCELID: event.parcel_id,
          geometry: event.geometry,
        };
        if (!parcelData) return;
        const feature = createParcelFeature({ parcel: parcelData });
        if (!feature) return;
        const parcelId = event.parcel_id || feature.properties?.parcelId;
        const parcelKey = parcelId ?? "__unknown__";
        appState.overlayStore.nextPlacementIndex.set(parcelKey, 0);
        upsertParcelFeature(feature, parcelId);
        const summary = {
          area_sqm: parcelData._area_sq_m
            ? Number(parcelData._area_sq_m).toFixed(1)
            : undefined,
          zoning: parcelData.official_zoning || parcelData.zoning_classification,
        };
        recordCrawlerEventSummary(event, summary);
        ingestParcelDataset({
          parcel: parcelData,
          summary: {
            parcel_id: parcelId,
            address:
              parcelData.SITEADDRESS ||
              parcelData.official_address ||
              parcelData.county_address,
          },
        });
      }

      function handlePlacementScoredEvent(event) {
        const placement =
          event.placement || event.payload || event.data || event;
        if (!placement) return;
        const parcelId =
          event.parcel_id || placement.parcel_id || placement.parcelId;
        const parcelKey = parcelId ?? "__unknown__";
        const placementIndex =
          placement.index ??
          placement.sequence ??
          placement.position ??
          placement.rank ??
          null;
        const feature = createPlacementFeature(placement, parcelId, false);
        if (feature) {
          const nextIndex =
            appState.overlayStore.nextPlacementIndex.get(parcelKey) || 0;
          appState.overlayStore.nextPlacementIndex.set(
            parcelKey,
            nextIndex + 1,
          );
          const key =
            placement.id ||
            placement.placement_id ||
            (placementIndex != null
              ? `${parcelKey}-idx-${placementIndex}`
              : `${parcelKey}-${nextIndex}`);
          upsertPlacementFeature(feature, key);
        }
        const shadowFeature = createShadowFeature(placement, parcelId, false);
        if (shadowFeature) {
          const shadowKey =
            placement.id ||
            `${parcelId || "parcel"}-${placement.sequence || Date.now()}-shadow`;
          upsertShadowFeature(shadowFeature, shadowKey);
        }
        const summary = {
          score: getPlacementCompositeScore(placement),
          rotation_deg: placement.rotation_deg,
          offset: [placement.offset_x_m, placement.offset_y_m],
          sequence: placement.sequence ?? placement.index,
          worker: placement.worker_id,
        };
        recordCrawlerEventSummary(event, summary);
        updateParcelPlacementDetail(parcelKey, placement, false);
      }

      function handleBestUpdatedEvent(event) {
        const placement =
          event.placement || event.best || event.payload || event;
        if (!placement) return;
        const parcelId =
          event.parcel_id || placement.parcel_id || placement.parcelId;
        const feature = createPlacementFeature(placement, parcelId, true);
        if (feature) {
          upsertBestFeature(feature, parcelId);
        }
        const shadowFeature = createShadowFeature(placement, parcelId, true);
        if (shadowFeature) {
          upsertShadowFeature(
            shadowFeature,
            `${parcelId || "parcel"}-best-shadow`,
          );
        }
        const summary = {
          score: getPlacementCompositeScore(placement),
          rotation_deg: placement.rotation_deg,
          offset: [placement.offset_x_m, placement.offset_y_m],
        };
        recordCrawlerEventSummary(event, summary);
        updateParcelPlacementDetail(parcelId, placement, true);
      }

      function isTerminalStatus(status) {
        if (!status) return false;
        const normalized = String(status).toLowerCase();
        return [
          "done",
          "complete",
          "completed",
          "finished",
          "failed",
          "error",
          "cancelled",
          "canceled",
        ].includes(normalized);
      }

      async function fetchJobStatus() {
        if (!appState.job) return;
        try {
          const data = await fetchJSON(
            `/jobs/${encodeURIComponent(appState.job.id)}`,
          );
          const status = data?.status || appState.job.status;
          appState.job.status = status;
          updateJobStatus(`Job ${status}...`);
          if (data?.log_tail) {
            updateLogTail(data.log_tail);
          }
          if (isTerminalStatus(status)) {
            finalizeJob(`Job ${status}.`);
          }
        } catch (err) {
          console.error(err);
          updateJobStatus(`Job status error: ${err.message}`, "error");
        }
      }

      async function fetchJobGeo() {
        if (!appState.job) return;
        logMessage("GET /jobs/{id}/geo", { id: appState.job.id });
        try {
          const data = await fetchJSON(
            `/jobs/${encodeURIComponent(appState.job.id)}/geo`,
          );
          const normalized = normalizeGeoResponse(data);
          if (
            Array.isArray(normalized.features) &&
            normalized.features.length
          ) {
            const collection = convertFeatureCollectionToLngLat(normalized);
            updateJobSource(collection);
            const featureCount = collection.features.length;
            const progress = extractProgress(data);
            if (progress) {
              updateJobMeta(
                `Parcels: ${featureCount} · Progress ${progress.completed ?? "?"}/${progress.total ?? "?"} (${hintsFromProgress(
                  progress,
                )})`,
              );
            } else {
              updateJobMeta(`Parcels returned: ${featureCount}`);
            }
            logMessage("Geo update", { featureCount, progress });
          } else {
            const progress = extractProgress(data);
            if (progress) {
              updateJobMeta(
                `Parcels pending · Progress ${progress.completed ?? "?"}/${progress.total ?? "?"} (${hintsFromProgress(
                  progress,
                )})`,
              );
            } else {
              updateJobMeta("No parcel GeoJSON yet.");
            }
          }
        } catch (err) {
          console.warn("Geo polling error", err);
          updateLogTail(err.message);
          logMessage("Geo polling error", { error: err.message }, "error");
        }
      }

      async function fetchJobArtifacts(jobIdOverride) {
        const jobId = jobIdOverride || appState.job?.id;
        if (!jobId) return;
        logMessage("GET /jobs/{id}/artifacts", { id: jobId });
        try {
          const manifest = await fetchJSON(
            `/jobs/${encodeURIComponent(jobId)}/artifacts`,
          );
          const parcels = manifest?.artifacts?.parcels || [];
          const artifactIndex = { ...appState.parcelArtifactIndex };
          parcels.forEach((entry) => {
            const normalized = normalizeParcelId(
              entry?.parcel_id || entry?.parcelId || entry?.LOWPARCELID,
            );
            const placementsUrl = normalizeArtifactUrl(
              entry?.placements_json_url,
            );
            if (normalized && placementsUrl) {
              artifactIndex[normalized] = placementsUrl;
            }
          });
          appState.parcelArtifactIndex = artifactIndex;
          if (!parcels.length) {
            return;
          }
          const urls = parcels
            .map((entry) => normalizeArtifactUrl(entry?.placements_json_url))
            .filter(Boolean);
          if (!urls.length) return;
          const cache = appState.overlayCache;
          if (cache.jobId && cache.jobId !== jobId) {
            cache.data = {};
            cache.index = 0;
          }
          cache.jobId = jobId;
          const fetchLimit = Math.min(8, urls.length);
          const freshUrls = urls.filter((url) => !cache.data[url]);
          const toFetch = [];
          while (toFetch.length < fetchLimit && freshUrls.length) {
            toFetch.push(freshUrls.shift());
          }
          if (toFetch.length < fetchLimit) {
            if (cache.index == null || cache.index >= urls.length) {
              cache.index = 0;
            }
            const seen = new Set(toFetch);
            let offset = 0;
            while (toFetch.length < fetchLimit && offset < urls.length) {
              const idx = (cache.index + offset) % urls.length;
              const candidate = urls[idx];
              if (!seen.has(candidate)) {
                toFetch.push(candidate);
                seen.add(candidate);
              }
              offset += 1;
            }
            cache.index = (cache.index + fetchLimit) % urls.length;
          }
          if (!toFetch.length) {
            return;
          }
          await Promise.all(
            toFetch.map(async (url) => {
              try {
                const data = await fetchExternalJSON(url, {
                  cache: "no-store",
                });
                if (data) {
                  cache.data[url] = data;
                }
              } catch (err) {
                logMessage(
                  "Placement fetch error",
                  { url, error: err.message },
                  "error",
                );
              }
            }),
          );

          const placementDatasets = Object.values(cache.data).filter(Boolean);
          placementDatasets.forEach((dataset) => ingestParcelDataset(dataset));
          const overlay = buildOverlayFromPlacements(placementDatasets);
          setOverlayStoreFromCollections(overlay);
        } catch (err) {
          const message = err?.message || "";
          if (message.includes("Artifacts not available yet")) {
            logMessage("Artifact polling pending", { detail: message });
            return;
          }
          console.warn("Artifact polling error", err);
          updateLogTail(err.message);
          logMessage("Artifact polling error", { error: err.message }, "error");
        }
      }
      function normalizeGeoResponse(payload) {
        if (!payload) return EMPTY_GEOJSON;
        if (
          payload.type === "FeatureCollection" &&
          Array.isArray(payload.features)
        ) {
          return payload;
        }
        const features = [];
        const segments =
          payload?.features ||
          payload?.items ||
          payload?.geojson ||
          payload?.data ||
          payload?.collection ||
          payload?.parcels ||
          payload?.queue ||
          [];
        if (Array.isArray(segments)) {
          segments.forEach((item) => {
            if (item?.type === "Feature") {
              features.push(item);
            } else if (item?.geometry) {
              features.push({
                type: "Feature",
                geometry: item.geometry,
                properties: item.properties || {},
              });
            }
          });
        }
        return { type: "FeatureCollection", features };
      }

      function extractProgress(payload) {
        if (!payload) return null;
        const sources = [
          payload.progress,
          payload.properties?.progress,
          payload.metadata?.progress,
          payload.status,
          payload,
        ];
        const found = sources.find(
          (source) =>
            source &&
            (source.completed !== undefined || source.total !== undefined),
        );
        if (!found) return null;
        return {
          completed: found.completed ?? found.done ?? found.current ?? null,
          total: found.total ?? found.expected ?? found.limit ?? null,
          extra: {
            queued: found.queued ?? null,
            remaining: found.remaining ?? null,
            running: found.running ?? null,
          },
        };
      }

      function hintsFromProgress(progress) {
        const hints = [];
        if (progress.extra?.queued)
          hints.push(`${progress.extra.queued} queued`);
        if (progress.extra?.running)
          hints.push(`${progress.extra.running} running`);
        if (progress.extra?.remaining)
          hints.push(`${progress.extra.remaining} remaining`);
        return hints.length ? hints.join(", ") : "no queue";
      }
      function sampleCoordinate(coords) {
        if (!Array.isArray(coords)) return null;
        if (
          coords.length >= 2 &&
          Number.isFinite(coords[0]) &&
          Number.isFinite(coords[1])
        )
          return coords;
        for (const item of coords) {
          const found = sampleCoordinate(item);
          if (found) return found;
        }
        return null;
      }

      function isLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return true;
        return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90;
      }

      function mercatorToLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return coord;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return coord;
        const lng = (x / 20037508.34) * 180;
        let lat = (y / 20037508.34) * 180;
        lat =
          (180 / Math.PI) *
          (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);
        return [lng, lat];
      }

      function convertCoordinates(coords) {
        if (!Array.isArray(coords)) return coords;
        if (coords.length >= 2 && typeof coords[0] === "number") {
          return mercatorToLngLat(coords);
        }
        return coords.map((sub) => convertCoordinates(sub));
      }

      function convertCoordsIfNeeded(coords) {
        if (!Array.isArray(coords)) return coords;
        const sample = sampleCoordinate(coords);
        if (!sample || isLngLat(sample)) return coords;
        return convertCoordinates(coords);
      }

      function boundsToPolygon(bounds) {
        if (!bounds) return null;
        const { xmin, ymin, xmax, ymax } = bounds;
        if (
          [xmin, ymin, xmax, ymax].some(
            (value) => typeof value !== "number" || Number.isNaN(value),
          )
        ) {
          return null;
        }
        return [
          [xmin, ymin],
          [xmax, ymin],
          [xmax, ymax],
          [xmin, ymax],
          [xmin, ymin],
        ];
      }

      function computeCentroid(coords) {
        if (!Array.isArray(coords) || !coords.length) return null;
        const flat = coords.flat(Infinity);
        if (!flat.length) return null;
        const points = [];
        function collect(array) {
          if (array.length >= 2 && typeof array[0] === "number") {
            points.push(array);
          } else {
            array.forEach(collect);
          }
        }
        collect(coords);
        if (!points.length) return null;
        const sum = points.reduce(
          (acc, [x, y]) => {
            acc[0] += x;
            acc[1] += y;
            return acc;
          },
          [0, 0],
        );
        return [sum[0] / points.length, sum[1] / points.length];
      }

      function createFeatureFromCoords(coords, properties = {}) {
        if (!coords) return null;
        const converted = convertCoordsIfNeeded(coords);
        return {
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [converted] },
          properties,
        };
      }

      function updateOverlaySources(data) {
        appState.overlayData = data;
        if (!map) return;
        if (map.getSource(PARCEL_BOUNDARY_SOURCE_ID)) {
          map
            .getSource(PARCEL_BOUNDARY_SOURCE_ID)
            .setData(data.parcels || EMPTY_GEOJSON);
        }
        if (map.getSource(PLACEMENT_SOURCE_ID)) {
          map
            .getSource(PLACEMENT_SOURCE_ID)
            .setData(data.placements || EMPTY_GEOJSON);
        }
        if (map.getSource(SHADOW_SOURCE_ID)) {
          map
            .getSource(SHADOW_SOURCE_ID)
            .setData(data.shadows || EMPTY_GEOJSON);
        }
        if (map.getSource(PLACEMENT_LABEL_SOURCE_ID)) {
          map
            .getSource(PLACEMENT_LABEL_SOURCE_ID)
            .setData(data.labels || EMPTY_GEOJSON);
        }
        const parcelCount = data.parcels?.features?.length || 0;
        const placementCount = data.placements?.features?.length || 0;
        const shadowCount = data.shadows?.features?.length || 0;
        if (ui.parcelSummary) {
          ui.parcelSummary.textContent = `Parcels: ${parcelCount}`;
        }
        if (ui.placementSummary) {
          ui.placementSummary.textContent = `Placements: ${placementCount}`;
        }
        if (ui.shadowSummary) {
          ui.shadowSummary.textContent = `Shadows: ${shadowCount}`;
        }
      }

      function requestOverlayRefresh(delay = 0) {
        if (appState.overlayRefreshPending) return;
        appState.overlayRefreshPending = true;
        setTimeout(() => {
          appState.overlayRefreshPending = false;
          fetchJobArtifacts();
        }, delay);
      }

      function clearOverlayStore() {
        const store = appState.overlayStore;
        store.parcels.clear();
        store.placements.clear();
        store.shadows.clear();
        store.labels.clear();
        store.best.clear();
        store.nextPlacementIndex.clear();
        store.parcelDetails.clear();
      }

      function renderOverlayFromStore() {
        const store = appState.overlayStore;
        const parcels = Array.from(store.parcels.values());
        const placements = Array.from(store.placements.values());
        const best = Array.from(store.best.values());
        const shadows = Array.from(store.shadows.values());
        const labels = Array.from(store.labels.values());
        updateOverlaySources({
          parcels: {
            type: "FeatureCollection",
            features: parcels,
          },
          placements: {
            type: "FeatureCollection",
            features: placements.concat(best),
          },
          shadows: {
            type: "FeatureCollection",
            features: shadows,
          },
          labels: {
            type: "FeatureCollection",
            features: labels,
          },
        });
      }

      function setOverlayStoreFromCollections(collections) {
        const store = appState.overlayStore;
        const parcelFeatures = collections.parcels?.features || [];
        const shadowFeatures = collections.shadows?.features || [];
        const placementFeatures = collections.placements?.features || [];
        const bestFeatures = collections.best?.features || [];
        if (
          !parcelFeatures.length &&
          !shadowFeatures.length &&
          !placementFeatures.length
        ) {
          return;
        }
        parcelFeatures.forEach((feature, index) => {
          const key =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            `parcel-${index}`;
          store.parcels.set(key, feature);
          ingestParcelSummaryFromOverlayFeature(feature);
        });
        shadowFeatures.forEach((feature, index) => {
          const key =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            `shadow-${index}`;
          store.shadows.set(key, feature);
        });
        const placementCounts = new Map();
        bestFeatures.forEach((feature) => {
          const parcelId =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            `best-${Date.now()}`;
          store.best.set(parcelId, feature);
          const label = createLabelFeature(feature);
          if (label) {
            store.labels.set(`${parcelId}-best-label`, label);
          }
        });
        placementFeatures.forEach((feature, index) => {
          const parcelIdForFeature =
            feature.properties?.parcelId ||
            feature.properties?.id ||
            "parcel";
          const key =
            feature.properties?.placementKey ||
            `${parcelIdForFeature}-placement-${index}`;
          store.placements.set(key, feature);
          const parcelIdForCount = parcelIdForFeature;
          const current = placementCounts.get(parcelIdForCount) || 0;
          placementCounts.set(parcelIdForCount, current + 1);
          const label = createLabelFeature(feature);
          if (label) {
            store.labels.set(`${key}-label`, label);
          }
        });
        placementCounts.forEach((count, parcelId) => {
          store.nextPlacementIndex.set(parcelId, count);
        });
        renderOverlayFromStore();
      }

      function upsertParcelFeature(feature, parcelId) {
        if (!feature) return;
        const key =
          parcelId ||
          feature.properties?.parcelId ||
          feature.properties?.id ||
          `parcel-${Date.now()}`;
        appState.overlayStore.parcels.set(key, feature);
        renderOverlayFromStore();
      }

      function upsertPlacementFeature(feature, key) {
        if (!feature) return;
        const placementKey =
          key ||
          feature.properties?.placementKey ||
          `${feature.properties?.parcelId || "parcel"}-${Date.now()}`;
        appState.overlayStore.placements.set(placementKey, feature);
        const label = createLabelFeature(feature);
        if (label) {
          appState.overlayStore.labels.set(`${placementKey}-label`, label);
        }
        renderOverlayFromStore();
      }

      function upsertShadowFeature(feature, key) {
        if (!feature) return;
        const shadowKey = key || `${feature.properties?.parcelId || "shadow"}-${Date.now()}`;
        appState.overlayStore.shadows.set(shadowKey, feature);
        renderOverlayFromStore();
      }

      function upsertBestFeature(feature, parcelId) {
        if (!feature) return;
        const key =
          parcelId ||
          feature.properties?.parcelId ||
          feature.properties?.id ||
          `best-${Date.now()}`;
        appState.overlayStore.best.set(key, feature);
        const label = createLabelFeature(feature);
        if (label) {
          appState.overlayStore.labels.set(`${key}-best-label`, label);
        }
        renderOverlayFromStore();
      }

      function updateLogTail(text) {
        if (!text) return;
        pushStatusUpdate(text, "info");
      }

      function clearOverlayData() {
        clearOverlayStore();
        renderOverlayFromStore();
        appState.overlayCache.data = {};
        appState.overlayCache.index = 0;
        appState.overlayCache.jobId = appState.job?.id || null;
        appState.parcelArtifactIndex = {};
        appState.selectedParcelId = null;
        resetParcelInfoPanel();
        updateSelectedParcelHighlight();
        clearParcelTooltip();
        appState.leaderboardEntries = [];
        appState.leaderboardSelectedId = null;
        renderLeaderboard();
      }

      function normalizePolygonGeometry(input) {
        if (!input) return null;
        if (input.type && input.coordinates) {
          return convertGeometryToLngLat(input);
        }
        const converted = convertCoordsIfNeeded(input);
        if (!Array.isArray(converted)) return null;
        const coordinates =
          converted[0] && Array.isArray(converted[0][0])
            ? converted
            : [converted];
        return { type: "Polygon", coordinates };
      }

      function createParcelFeature(data) {
        if (!data?.parcel) return null;
        let geometry =
          normalizePolygonGeometry(
            data.parcel.geometry ||
              data.parcel.polygon ||
              data.parcel.coordinates,
          ) || null;
        if (!geometry) {
          const boundsPolygon = boundsToPolygon(data.parcel._bounds);
          geometry = normalizePolygonGeometry(boundsPolygon);
        }
        if (!geometry) return null;
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId:
              data.parcel.LOWPARCELID ||
              data.parcel.parcel_id ||
              data.summary?.parcel_id,
            address: data.parcel.SITEADDRESS || data.summary?.address,
          },
        };
      }

      function getPlacementCompositeScore(placement) {
        if (!placement) return null;
        const value =
          placement.composite_score ??
          placement.composite ??
          placement.score ??
          placement.score_total ??
          placement.scores?.composite ??
          null;
        if (value == null) return null;
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function createPlacementFeature(placement, parcelId, isBest) {
        const placementIndex =
          placement.index ??
          placement.sequence ??
          placement.position ??
          placement.rank ??
          null;
        const parcelKey =
          parcelId || placement.parcel_id || placement.parcelId || "parcel";
        const geometry =
          normalizePolygonGeometry(placement.footprint_geojson) ||
          normalizePolygonGeometry(
            placement.footprint_points ||
              placement.footprint ||
              placement.polygon ||
              placement.coordinates,
          );
        if (!geometry) return null;
        const composite = getPlacementCompositeScore(placement);
        const fallbackSuffix =
          placementIndex != null
            ? `idx-${placementIndex}`
            : `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        const placementKey =
          placement.id ||
          placement.placement_id ||
          `${parcelKey || "parcel"}-${fallbackSuffix}`;
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId,
            score: composite != null ? Number(composite).toFixed(2) : "n/a",
            rawScore: composite,
            isBest: Boolean(isBest),
            index: placementIndex,
            placementKey,
          },
        };
      }

      function createShadowFeature(placement, parcelId, isBest) {
        const geometry =
          normalizePolygonGeometry(placement.shadow_geojson) ||
          normalizePolygonGeometry(
            placement.shadow ||
              placement.shadow_polygon ||
              placement.shadow_outline,
          );
        if (!geometry) return null;
        return {
          type: "Feature",
          geometry,
          properties: {
            parcelId,
            isBest: Boolean(isBest),
          },
        };
      }

      function createLabelFeature(feature) {
        if (!feature?.geometry?.coordinates) return null;
        if (!feature.properties?.isBest) return null;
        const centroid = computeCentroid(feature.geometry.coordinates);
        if (!centroid) return null;
        const converted = convertCoordsIfNeeded([centroid])[0];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: converted,
          },
          properties: {
            parcelId: feature.properties?.parcelId,
            score: feature.properties?.score,
            isBest: feature.properties?.isBest,
          },
        };
      }

      function buildOverlayFromPlacements(datasets) {
        const parcelFeatures = [];
        const placementFeatures = [];
        const shadowFeatures = [];
        const labelFeatures = [];

        datasets.forEach((dataset) => {
          if (!dataset) return;
          const parcelId =
            dataset.summary?.parcel_id ||
            dataset.parcel?.LOWPARCELID ||
            dataset.parcel?.parcel_id;
          const parcelFeature = createParcelFeature(dataset);
          if (parcelFeature) parcelFeatures.push(parcelFeature);
          const placements = Array.isArray(dataset.placements)
            ? dataset.placements
            : [];
          if (!placements.length) return;
          let bestScore = -Infinity;
          placements.forEach((placement) => {
            const composite = getPlacementCompositeScore(placement);
            if (composite != null && composite > bestScore) {
              bestScore = composite;
            }
          });
          placements.forEach((placement, idx) => {
            const normalizedPlacement = { ...placement };
            if (
              normalizedPlacement.index == null &&
              normalizedPlacement.sequence == null &&
              normalizedPlacement.position == null &&
              normalizedPlacement.rank == null
            ) {
              normalizedPlacement.index = idx;
            }
            const composite = getPlacementCompositeScore(placement);
            const numericScore = composite;
            const isBest =
              bestScore !== -Infinity && !Number.isNaN(numericScore)
                ? numericScore === bestScore
                : false;
            const placementFeature = createPlacementFeature(
              normalizedPlacement,
              parcelId,
              isBest,
            );
            if (placementFeature) {
              placementFeatures.push(placementFeature);
              const labelFeature = createLabelFeature(placementFeature);
              if (labelFeature) labelFeatures.push(labelFeature);
            }
            const shadowFeature = createShadowFeature(
              placement,
              parcelId,
              isBest,
            );
            if (shadowFeature) shadowFeatures.push(shadowFeature);
          });
        });

        return {
          parcels: { type: "FeatureCollection", features: parcelFeatures },
          placements: {
            type: "FeatureCollection",
            features: placementFeatures,
          },
          shadows: { type: "FeatureCollection", features: shadowFeatures },
          labels: { type: "FeatureCollection", features: labelFeatures },
        };
      }

      function sampleCoordinate(coords) {
        if (!Array.isArray(coords)) return null;
        if (
          coords.length >= 2 &&
          Number.isFinite(coords[0]) &&
          Number.isFinite(coords[1])
        ) {
          return coords;
        }
        for (const item of coords) {
          const found = sampleCoordinate(item);
          if (found) return found;
        }
        return null;
      }

      function isLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return true;
        return Math.abs(coord[0]) <= 180 && Math.abs(coord[1]) <= 90;
      }

      function mercatorToLngLat(coord) {
        if (!Array.isArray(coord) || coord.length < 2) return coord;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return coord;
        const lng = (x / 20037508.34) * 180;
        let lat = (y / 20037508.34) * 180;
        lat =
          (180 / Math.PI) *
          (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);
        return [lng, lat];
      }

      function convertCoordinates(coords) {
        if (!Array.isArray(coords)) return coords;
        if (coords.length >= 2 && typeof coords[0] === "number") {
          return mercatorToLngLat(coords);
        }
        return coords.map((sub) => convertCoordinates(sub));
      }

      function convertGeometryToLngLat(geometry) {
        if (!geometry || !geometry.coordinates) return geometry;
        const sample = sampleCoordinate(geometry.coordinates);
        if (!sample || isLngLat(sample)) return geometry;
        return {
          ...geometry,
          coordinates: convertCoordinates(geometry.coordinates),
        };
      }

      function convertFeatureCollectionToLngLat(collection) {
        if (!collection || !Array.isArray(collection.features))
          return collection;
        const features = collection.features.map((feature) => {
          if (!feature?.geometry) return feature;
          return {
            ...feature,
            geometry: convertGeometryToLngLat(feature.geometry),
          };
        });
        return { ...collection, features };
      }

      function finalizeJob(message) {
        const finishedJobId = appState.job?.id;
        clearJobPolling();
        clearJobMarker();
        stopEventStream();
        setControlsDisabled(false);
        setJobControlState("clear");
        updateJobStatus(message || "Job finished.");
        logMessage("Job finalized", { message, jobId: finishedJobId });
        appState.job = null;
        fetchJobArtifacts(finishedJobId);
        pushStatusUpdate(message || "Job finished.", "success");
      }

      function abortOngoingApiCalls() {
        appState.abortControllers.forEach((controller) => controller.abort());
        appState.abortControllers.clear();
      }

      function cancelActiveJob(reason, notify = false, options = {}) {
        const { clearOverlays = true } = options;
        if (!appState.job) return;
        const jobId = appState.job.id;
        updateJobStatus(reason || "Job cancelled.", "error");
        updateJobMeta("");
        if (notify && jobId) {
          sendCancellationSignal(jobId, reason);
        }
        clearJobPolling();
        abortOngoingApiCalls();
        clearJobMarker();
        appState.job = null;
        setControlsDisabled(false);
        if (clearOverlays) {
          updateJobSource(EMPTY_GEOJSON);
          updateLogTail("");
          clearOverlayData();
          resetEventFeed("No activity yet.");
          setJobControlState("hidden");
        }
        pushStatusUpdate(reason || "Job cancelled.", "error");
        stopEventStream();
      }

      function handleStopJob() {
        if (!appState.job) return;
        cancelActiveJob("Job stopped by user.", true, { clearOverlays: false });
        updateJobStatus(
          "Job stopped. Review results, then clear when you're ready.",
        );
        updateJobMeta("");
        pushStatusUpdate("Job stopped by user.", "info");
        setJobControlState("clear");
      }

      function clearJobView() {
        updateJobSource(EMPTY_GEOJSON);
        clearOverlayData();
        resetEventFeed("No activity yet.");
        pushStatusUpdate("View cleared.", "info");
        updateJobStatus("Select a design and long press on the map to start a crawl.");
        updateJobMeta("");
        setJobControlState("hidden");
      }

      function sendCancellationSignal(jobId, reason) {
        if (!jobId) return;
        const url = `${API_BASE}/jobs/${encodeURIComponent(jobId)}/cancel`;
        const payload = JSON.stringify({ reason: reason || "client_left" });
        if (navigator.sendBeacon) {
          const blob = new Blob([payload], { type: "application/json" });
          navigator.sendBeacon(url, blob);
        } else {
          fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: payload,
            keepalive: true,
          }).catch(() => {});
        }
      }

      function formatAddress(feature) {
        const p = feature?.properties || {};
        const parts = [
          [p.housenumber, p.street].filter(Boolean).join(" ").trim() || null,
          p.neighbourhood || null,
          p.city || p.town || p.village || null,
          p.state || p.region || null,
          p.postcode || null,
          p.country || null,
        ].filter(Boolean);
        if (parts.length) return parts.join(", ");
        return feature?.place_name || "Address not found";
      }

      async function reverseGeocode(lngLat) {
        const url = `https://api.maptiler.com/geocoding/${lngLat.lng},${lngLat.lat}.json?type=address&limit=1&key=${key}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Reverse geocoding failed");
        const data = await res.json();
        const feature = data.features && data.features[0];
        return formatAddress(feature);
      }

      function showPopup(lngLat, text) {
        const popup = new maplibregl.Popup()
          .setLngLat(lngLat)
          .setHTML(
            `<strong>${text}</strong><br>Lat: ${lngLat.lat.toFixed(5)}, Lng: ${lngLat.lng.toFixed(5)}`,
          )
          .addTo(map);
        popup.on("close", () => {
          if (addressPopup === popup) {
            addressPopup = null;
          }
        });
        return popup;
      }

      function attachLongPressHandler() {
        if (!map) return;

        map.on("mousedown", (e) => {
          clearTimeout(longPressTimer);
          longPressTimer = setTimeout(async () => {
            longPressCoords = e.lngLat;
            suppressNextClick = true;
            try {
              if (!canStartJob()) return;
              await startJobAtPoint(longPressCoords);
            } catch (err) {
              console.error("Long-press job start failed", err);
            }
          }, 600);
        });

        map.on("mouseup", () => {
          clearTimeout(longPressTimer);
        });

        map.on("mouseleave", () => {
          clearTimeout(longPressTimer);
        });
      }

      ui.refreshDesignsBtn.addEventListener("click", loadDesigns);
      ui.designSelect.addEventListener("change", handleDesignChange);
      if (ui.cancelJobBtn) {
        ui.cancelJobBtn.addEventListener("click", handleJobControlClick);
      }
      if (ui.mobileCancelBtn) {
        ui.mobileCancelBtn.addEventListener("click", handleJobControlClick);
      }
      if (ui.mobileDesignToggle) {
        ui.mobileDesignToggle.addEventListener("click", (event) => {
          event.stopPropagation();
          toggleMobileDesignMenu();
        });
      }
      if (ui.mobileDesignMenu) {
        ui.mobileDesignMenu.addEventListener("click", (event) =>
          event.stopPropagation(),
        );
      }
      document.addEventListener("click", () => {
        if (appState.mobileDesignMenuOpen) {
          closeMobileDesignMenu();
        }
      });
      const leaderboardCard = document.getElementById("leaderboardCard");
      if (leaderboardCard) {
        let trayDragStartY = null;
        leaderboardCard.addEventListener("click", () => {
          if (!appState.leaderboardOpen) {
            setLeaderboardTray(true);
          }
        });
        leaderboardCard.addEventListener(
          "touchstart",
          (event) => {
            if (!event.touches.length) return;
            trayDragStartY = event.touches[0].clientY;
          },
          { passive: true },
        );
        leaderboardCard.addEventListener(
          "touchend",
          (event) => {
            if (trayDragStartY == null) return;
            const endY = event.changedTouches[0].clientY;
            const delta = endY - trayDragStartY;
            if (Math.abs(delta) > 30) {
              if (delta > 0) {
                setLeaderboardTray(false);
              } else {
                setLeaderboardTray(true);
              }
            } else if (!appState.leaderboardOpen) {
              setLeaderboardTray(true);
            }
            trayDragStartY = null;
          },
          { passive: true },
        );
      }
      if (ui.leaderboardToggle) {
        ui.leaderboardToggle.addEventListener("click", (event) => {
          event.stopPropagation();
          toggleLeaderboardTray();
        });
      }

      window.addEventListener("beforeunload", () => {
        cancelActiveJob("Page closing. Cancelling crawl.", true);
      });

      function detectMobile() {
        const mobileUA =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent,
          );
        const smallScreen = window.matchMedia("(max-width: 768px)").matches;
        if (mobileUA || smallScreen) {
          document.body.classList.add("mobile-mode");
        }
      }

      detectMobile();
      initMap();
      loadDesigns();
      updateJobStatus("Select a design and long press on the map to start a crawl.");
      resetParcelInfoPanel();
      resetEventFeed("No activity yet.");
      renderLeaderboard();
      setDesktopLeaderboardVisibility(false);
    </script>
  </body>
</html>
      .panel-section {
        background: #f8fafc;
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: 18px;
        padding: 16px 18px 18px;
      }

      .panel-section.panel-log {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .status-feed {
        flex: 1;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: #ffffff;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 120px;
      }

      .status-item {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #2563eb;
        margin-top: 6px;
      }

      .status-item.error .status-dot {
        background: #dc2626;
      }

      .status-item.success .status-dot {
        background: #16a34a;
      }

      .status-item.muted .status-dot {
        background: rgba(148, 163, 184, 0.6);
      }

      .status-message {
        font-size: 0.9rem;
        color: #0f172a;
        font-weight: 600;
      }

      .status-time {
        font-size: 0.75rem;
        color: #64748b;
        margin-top: 2px;
      }
      .visually-hidden {
        position: absolute;
        opacity: 0;
        pointer-events: none;
        height: 0;
        width: 0;
      }
